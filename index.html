<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Offline Transcriber — Vosk (WASM)</title>
  <style>
    :root{
      --bg:#111418;--panel:#161b21;--fg:#e8eef7;--muted:#9aa6b2;--line:#273044;--accent:#ffd666;
      /* MOBILE TUNABLES */
      --mobile-max:420px;     /* fixed mobile width (change this if UI grows/shrinks) */
      --m-lines:3;            /* # of lines in mobile transcript window */
      --m-lh:1.6;             /* line-height multiplier */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,Segoe UI,Arial,sans-serif;overflow-x:hidden}

    /* ===== Desktop header (unchanged) ===== */
    header{display:grid;gap:10px;align-items:center;padding:12px;background:var(--panel);position:sticky;top:0;z-index:5;border-bottom:1px solid var(--line);grid-template-columns:repeat(12,minmax(0,1fr))}
    .field{display:flex;flex-direction:column;gap:6px}.field .lbl{font-size:12px;color:var(--muted)}
    header .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    header .meter{display:flex;gap:10px;align-items:center;justify-content:flex-end}
    header .opts{display:flex;gap:16px;align-items:center}
    header .field.audio{grid-column:span 4}header .field.ref{grid-column:span 4}
    header .actions{grid-column:span 4}header .opts{grid-column:span 6}header .meter{grid-column:span 6}
    header .playerRow{grid-column:1/-1}
    button,input,select{background:#1e2430;border:1px solid #2b3342;color:var(--fg);border-radius:10px;padding:10px 12px}
    button:hover{filter:brightness(1.06)}button:disabled{opacity:.5;cursor:not-allowed;filter:none}
    button.primary{background:var(--accent);color:#000;border-color:transparent}
    button.danger{background:#ff6b6b;color:#000;border-color:#ff9e9e}
    progress{height:12px;width:240px}
    #playerDesktop{width:100%;height:42px;background:#0f131a;border-radius:10px}

    #grid{display:grid;grid-template-columns:2fr 1fr;gap:12px;padding:12px}
    .pane{border:1px solid var(--line);border-radius:10px;overflow:auto}
    .pane .ttl{padding:8px 12px;border-bottom:1px solid var(--line);background:#131821;position:sticky;top:0}
    #text{padding:12px;white-space:pre-wrap}
    .token{padding:2px 3px;border-radius:6px;cursor:pointer}.token:hover{background:#1e2733}.token.playing{background:var(--accent);color:#000}
    small{color:var(--muted)}.accent{background:var(--accent);color:#000;border-radius:6px;padding:0 5px}
    #log{font:12px/1.3 ui-monospace,Consolas,monospace;white-space:pre-wrap;padding:10px}.ok{color:#baffc1}.warn{color:#ffe9a6}.bad{color:#ffb4b4}
    #tbl{width:100%;border-collapse:collapse}#tbl th,#tbl td{border-bottom:1px solid #273044;padding:6px 8px;text-align:left;font-variant-numeric:tabular-nums}
    #tbl th.play,#tbl td.play{width:48px}.playbtn{cursor:pointer;border:1px solid #2b3342;background:#1e2430;border-radius:6px;padding:2px 6px}.playbtn:hover{filter:brightness(1.1)}
    .row{display:flex;gap:10px;align-items:center;padding:10px;border-top:1px solid var(--line);background:#131821}

    @media (max-width:1100px){header .field.audio,header .field.ref{grid-column:span 6}header .actions{grid-column:span 6}header .opts{grid-column:span 6}header .meter{grid-column:span 6}}
    @media (max-width:820px){#grid{grid-template-columns:1fr}}
    @media (max-width:720px){header{grid-template-columns:repeat(6,minmax(0,1fr))}header .field.audio,header .field.ref,header .actions,header .opts,header .meter{grid-column:1/-1}progress{width:100%}}

    .topbar{grid-column:1/-1;display:flex;align-items:center;gap:12px}.topbar .title{font-weight:600}

    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.45);backdrop-filter:saturate(120%) blur(2px);z-index:40}

    .drawer{position:fixed;inset:0 auto 0 0;width:82%;max-width:420px;background:var(--panel);border-right:1px solid var(--line);transform:translateX(-105%);transition:transform .18s ease-out;z-index:50;display:flex;flex-direction:column}
    .drawer.open{transform:translateX(0)}
    .drawer-head{display:flex;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid var(--line)}
    .drawer-title{font-weight:600}
    .xbtn{background:#1e2430;border:1px solid #2b3342;color:var(--fg);border-radius:10px;padding:8px 10px}
    .drawer-body{padding:12px;display:grid;gap:12px}
    .drawer .sec{display:grid;gap:8px}
    .drawer .sec .sec-title{font-size:12px;color:var(--muted);margin:4px 0 2px}

    /* ===== MOBILE UI ===== */
    :root[data-mobile="1"] body{font-size:16px}
    :root[data-mobile="1"] header{display:none}
    :root[data-mobile="0"] #mobileApp{display:none}

    #mobileApp{display:grid;grid-template-rows:auto auto 1fr auto;gap:16px;padding:14px;
      width:100%;max-width:var(--mobile-max);margin:0 auto}

    #mBar{display:flex;align-items:center;gap:10px}
    #mMenu{width:42px;height:42px;border-radius:10px;border:1px solid #2b3342;background:#1e2430;display:flex;align-items:center;justify-content:center}
    #mMenu span{display:block;width:18px;height:2px;background:var(--fg);position:relative}
    #mMenu span::before,#mMenu span::after{content:"";position:absolute;left:0;width:18px;height:2px;background:var(--fg)}
    #mMenu span::before{top:-6px}#mMenu span::after{top:6px}

    #mTitle{font-size:24px;font-weight:800;flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    #mTimes{display:flex;justify-content:space-between;font-variant-numeric:tabular-nums}
    #mSeek{appearance:none;width:100%;height:20px;border-radius:10px;background:#0f131a;border:1px solid var(--line);outline:none}
    #mSeek::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);border:none}
    #mSeek::-moz-range-thumb{width:18px;height:18px;border:none;border-radius:50%;background:var(--accent)}

    #mViewport{border:1px solid var(--line);border-radius:12px;background:#cfd3da0a;padding:10px 12px;overflow:hidden;position:relative}
    #mText{
      line-height:var(--m-lh);
      white-space:pre-wrap;
      overflow:auto;
      height:calc(var(--m-lh) * 1em * var(--m-lines) + 12px);
      scrollbar-width:none;word-break:break-word;overflow-wrap:break-word;
    }
    #mText::-webkit-scrollbar{display:none}
    #mText .token{padding:4px 6px;border-radius:8px}
    #mText .token.playing{background:var(--accent);color:#000}

    #mChapterRow{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;align-items:center}
    .mChip{font-size:18px;text-align:center;border:1px solid var(--line);border-radius:10px;padding:8px 10px;background:#1a1f28}

    #mTransport{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
    .mBtn{display:flex;align-items:center;justify-content:center;border-radius:16px;padding:18px;border:1px solid #2b3342;background:#1e2430;font-size:24px}
    .mBtn:active{transform:scale(.98)}
    #mBottom{display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin-top:2px}
    #mBottom .pill{display:flex;align-items:center;justify-content:center;border:1px solid var(--line);border-radius:12px;padding:10px 8px;background:#141923}

    #speedPopover{position:fixed;z-index:60;min-width:220px;border:1px solid var(--line);background:#0f131a;border-radius:12px;padding:10px;display:none;box-shadow:0 6px 20px rgba(0,0,0,.45)}
    #speedPopover .row{display:flex;gap:8px;flex-wrap:wrap}
    .speedOpt{flex:1;border:1px solid #2b3342;background:#1e2430;border-radius:10px;padding:8px 10px;text-align:center;cursor:pointer}
    .speedOpt:hover{filter:brightness(1.07)}
    .speedCustom{display:flex;gap:8px;margin-top:8px}
    .speedCustom input{flex:1;text-align:center}
    .speedCustom button{padding:10px 12px}

    :root[data-mobile="1"] #grid{display:none}
  </style>

  <!-- set data-mobile ASAP -->
  <script>
    (function(){
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent||'')
        || (window.matchMedia && matchMedia('(pointer:coarse)').matches)
        || (typeof window!=='undefined' && window.innerWidth<=768);
      document.documentElement.setAttribute('data-mobile',isMobile?'1':'0');
    })();
  </script>
</head>
<body>

  <!-- ===== MOBILE SHELL ===== -->
  <main id="mobileApp">
    <div id="mBar">
      <button id="mMenu" aria-label="Open menu"><span></span></button>
      <div id="mTitle">No audio loaded</div>
    </div>

    <section>
      <div id="mTimes">
        <div id="mElapsed">0:00</div>
        <div id="mRemain">-0:00</div>
        <div id="mTotal">0:00</div>
      </div>
      <input id="mSeek" type="range" min="0" max="1000" step="1" value="0" />
    </section>

    <section id="mViewport">
      <div id="mText">(no transcript yet)</div>
    </section>

    <section id="mChapterRow">
      <div id="mChapterIdx" class="mChip">—</div>
      <div id="mChapterClock" class="mChip">—</div>
      <div id="mChapterLen" class="mChip">—</div>
    </section>

    <section id="mTransport">
      <button id="mPrev" class="mBtn" title="Back 10s">⏮</button>
      <button id="mPlay" class="mBtn" title="Play/Pause">▶</button>
      <button id="mNext" class="mBtn" title="Forward 10s">⏭</button>
    </section>

    <section id="mBottom">
      <div class="pill" id="mRB">RB</div>
      <div class="pill" id="mSpeed">1.00×</div>
      <div class="pill" id="mVol">V ±</div>
      <div class="pill" id="mDP">DP</div>
      <div class="pill" id="mMore">⋯</div>
    </section>

    <audio id="player" hidden></audio>
  </main>

  <!-- Speed popover -->
  <div id="speedPopover" role="dialog" aria-label="Playback speed">
    <div class="row">
      <div class="speedOpt" data-sp="0.75">0.75×</div>
      <div class="speedOpt" data-sp="0.90">0.90×</div>
      <div class="speedOpt" data-sp="1.00">1.00×</div>
      <div class="speedOpt" data-sp="1.10">1.10×</div>
      <div class="speedOpt" data-sp="1.20">1.20×</div>
      <div class="speedOpt" data-sp="1.25">1.25×</div>
      <div class="speedOpt" data-sp="1.50">1.50×</div>
      <div class="speedOpt" data-sp="1.55">1.55×</div>
      <div class="speedOpt" data-sp="2.00">2.00×</div>
    </div>
    <div class="speedCustom">
      <input id="speedInput" type="number" step="0.01" min="0.50" max="3.00" placeholder="Custom (e.g. 1.55)" />
      <button id="speedApply" class="primary">Apply</button>
    </div>
  </div>

  <!-- ===== DESKTOP UI ===== -->
  <header>
    <div class="topbar">
      <div id="audioTitle" class="title">No audio loaded</div>
    </div>

    <div id="controlShelf">
      <div class="field audio">
        <div class="lbl">Audio</div>
        <!-- accept m4b -->
        <input id="audioFile" type="file" accept="audio/*,.m4b" />
      </div>
      <div class="field ref">
        <div class="lbl">Reference Text (optional)</div>
        <!-- accept epub -->
        <input id="refFile" type="file" accept=".txt,.epub,text/plain,application/epub+zip" />
      </div>
      <div class="actions">
        <button id="go" class="primary">Transcribe (current chapter)</button>
        <button id="align">Align &amp; Correct (current chapter)</button>
      </div>
      <div class="opts">
        <label style="display:flex;gap:8px;align-items:center">
          <input id="adaptiveToggle" type="checkbox"/><span class="lbl">Adaptive sync (experimental)</span>
        </label>
      </div>
      <div class="meter">
        <progress id="prog" max="100" value="0"></progress>
        <button id="cancelModel" class="danger" style="display:none">Cancel</button>
        <span id="status"><small>Ready</small></span>
      </div>
    </div>

    <div class="playerRow"><audio id="playerDesktop" controls></audio></div>
  </header>

  <div id="overlay" class="overlay" hidden></div>
  <aside id="drawer" class="drawer" aria-hidden="true" aria-label="Menu">
    <div class="drawer-head">
      <div class="drawer-title">Menu</div>
      <button id="closeDrawer" class="xbtn" aria-label="Close">✕</button>
    </div>
    <div id="drawerControls" class="drawer-body">
      <div class="sec" id="secFiles">
        <div class="sec-title">Files</div>
        <!-- audio/ref controls get moved here on mobile -->
      </div>

      <div class="sec" id="secChapters">
        <div class="sec-title">Chapter Mode</div>
        <div style="display:grid;gap:8px">
          <div>
            <div class="lbl">Audio chapters (.m4b)</div>
            <select id="audioChSel" size="6" style="width:100%"></select>
            <small id="audioChMeta" style="display:block;margin-top:4px;color:var(--muted)">(no audio chapters)</small>
          </div>
          <div>
            <div class="lbl">Text chapters (.epub)</div>
            <select id="textChSel" size="6" style="width:100%"></select>
            <small id="textChMeta" style="display:block;margin-top:4px;color:var(--muted)">(no text chapters)</small>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="lbl">Start at audio:</label>
            <input id="mapAudioIdx" type="number" min="0" step="1" value="0" style="width:80px">
            <label class="lbl">maps to text:</label>
            <input id="mapTextIdx" type="number" min="0" step="1" value="0" style="width:80px">
            <button id="applyMap">Apply</button>
          </div>
          <small id="mapInfo" style="color:var(--muted)">Offset = textStart - audioStart = 0</small>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button id="startChapterMode" class="primary">Start Chapter Mode</button>
            <button id="transcribeThisChapter">Transcribe Selected</button>
          </div>
        </div>
      </div>

      <div class="sec" id="secActions"><div class="sec-title">Actions</div></div>
      <div class="sec" id="secSettings"><div class="sec-title">Settings</div></div>
    </div>
  </aside>

  <div id="grid">
    <section class="pane">
      <div class="ttl">Transcript</div>
      <div id="text">(no transcript yet)</div>
      <div class="ttl">Per-word timestamps</div>
      <table id="tbl">
        <thead><tr><th class="play">▶</th><th>#</th><th>word</th><th class="mobile-hide">start</th><th class="mobile-hide">end</th><th class="mobile-hide">conf</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section class="pane">
      <div class="ttl">Log</div>
      <div id="log">(log starts here)</div>
      <div class="row">
        <button id="copy">Copy log</button>
        <button id="save">Download log</button>
        <div class="sp"></div>
        <small>Runs fully <span class="accent">offline</span> in your browser using Vosk WASM.</small>
      </div>
    </section>
  </div>

  <!-- deps -->
  <script src="https://unpkg.com/fflate@0.8.2/umd/index.js"></script>
  <script src="https://unpkg.com/vosk-browser@0.0.8/dist/vosk.js"></script>
  <!-- chapters / containers -->
  <script src="https://unpkg.com/mp4box@0.5.4/dist/mp4box.all.min.js"></script>
  <script src="https://unpkg.com/epubjs@0.3.93/dist/epub.min.js"></script>

  <script>
    window.addEventListener('error', e => {
      const log=document.getElementById('log');
      if (log){
        const d=document.createElement('div');
        d.className='bad';
        d.textContent='[JS ERROR] '+(e.message||e.error||'unknown');
        log.appendChild(d);
      }
      console.error(e);
    });

    /* ===================== Shared refs & state ===================== */
    const $=id=>document.getElementById(id);
    const el={
      audioFile:$("audioFile"),refFile:$("refFile"),
      go:$("go"),align:$("align"),
      prog:$("prog"),status:$("status"),log:$("log"),
      text:$("text"),tb:$("tbl")?.querySelector('tbody'),
      copy:$("copy"),save:$("save"),playerDesktop:$("playerDesktop"),
      adaptiveToggle:$("adaptiveToggle"),audioTitle:$("audioTitle"),
      cancelModel:$("cancelModel"),
      mobileApp:$("mobileApp"), mTitle:$("mTitle"), mSeek:$("mSeek"),
      mElapsed:$("mElapsed"), mRemain:$("mRemain"), mTotal:$("mTotal"),
      mText:$("mText"), mPrev:$("mPrev"), mPlay:$("mPlay"), mNext:$("mNext"),
      mChapterIdx:$("mChapterIdx"), mChapterClock:$("mChapterClock"), mChapterLen:$("mChapterLen"),
      mSpeed:$("mSpeed"), mMenu:$("mMenu"),
      speedPopover:$("speedPopover"), speedInput:$("speedInput"), speedApply:$("speedApply"),
      drawer:$("drawer"), overlay:$("overlay"), secFiles:$("secFiles"), secActions:$("secActions"), secSettings:$("secSettings"), closeDrawer:$("closeDrawer"),
      secChapters:$("secChapters"),
      audioChSel:$("audioChSel"), textChSel:$("textChSel"), audioChMeta:$("audioChMeta"), textChMeta:$("textChMeta"),
      mapAudioIdx:$("mapAudioIdx"), mapTextIdx:$("mapTextIdx"), applyMap:$("applyMap"), mapInfo:$("mapInfo"),
      startChapterMode:$("startChapterMode"), transcribeThisChapter:$("transcribeThisChapter"),
      player:$("player")
    };
    function isMobileUA(){
      const ua=navigator.userAgent||'';
      return /Mobi|Android|iPhone|iPad|iPod/i.test(ua)
          || (window.matchMedia && matchMedia('(pointer:coarse)').matches)
          || window.innerWidth<=768;
    }
    let IS_MOBILE=isMobileUA();
    function activePlayer(){ return IS_MOBILE ? el.player : el.playerDesktop; }

    const BASE = new URL('.', location.href);
    const MOBILE_MODEL_URL  = new URL('models/en-us-mobile.tar.gz', BASE).href;
    const DESKTOP_MODEL_URL = new URL('models/en-us-desktop.zip', BASE).href;
    const MODEL_URL = IS_MOBILE ? MOBILE_MODEL_URL : DESKTOP_MODEL_URL;

    /* --- App state --- */
    const HILITE_LEAD=.04,HILITE_LAG=.06,MIN_WORD=.08,CLICK_PAD=.04,CLICK_MIN=.3,GAP_PAD=.01;
    let ADAPTIVE_ON=false,driftBias=0; const DRIFT_ALPHA=.12,DRIFT_CLAMP=.25;
    let AUDIO_FILE=null,MODEL=null,RECOG=null,LOG=[];
    let MODEL_WATCH={active:false,start:0,lastBeat:0,timer:null,canceled:false};
    let LAST_WORDS=[],PLAY_WORDS=[],HWIN=[],REF_TEXT='',TOKENS=[],MOB_TOKENS=[],CUR_HI=-1,__playTimer=null,ALIGNED_ONCE=false;
    let CURRENT_RATE=1.00;

    // decoded cache for chapter slicing
    let DECODE_CACHE=null; // {f32,sr,durationSec}
    // chapters
    let AUDIO_CH=[]; // [{title,start,end}]
    let TEXT_CH=[];  // [{title, idx, text}]
    let MAP_OFFSET=0; // textIndex - audioIndex
    let CHAPTER_MODE=false;
    let CURRENT_AUDIO_CH_INDEX=0;
    let PREFETCHING=false;

    const NL='\n',ts=()=>new Date().toLocaleTimeString();
    function safe(o){try{if(o==null)return'';if(typeof o==='string')return o;return JSON.stringify(o,(k,v)=>typeof v==='bigint'?String(v):v)}catch{return'[unserializable]'}}

    function addLog(l,m,meta){
      const line=`[${ts()}] ${l.toUpperCase()}: ${m}${meta?` — ${safe(meta)}`:''}`;LOG.push(line);
      if(el.log){const d=document.createElement('div');d.textContent=line;d.className=l==='error'?'bad':l==='warn'?'warn':'ok';el.log.append(d);el.log.scrollTop=el.log.scrollHeight;}
      console[l==='error'?'error':l==='warn'?'warn':'log'](line,meta||'')
    }
    function setStatus(s){ if(el.status) el.status.innerHTML=`<small>${s}</small>`; addLog('info',s) }
    function setProg(v){ if(el.prog) el.prog.value=v }

    /* ========== Drawer & layout ========== */
    function setDrawer(open){
      if(open){ el.drawer.classList.add('open'); el.overlay.hidden=false; el.drawer.setAttribute('aria-hidden','false'); }
      else { el.drawer.classList.remove('open'); el.overlay.hidden=true; el.drawer.setAttribute('aria-hidden','true'); }
    }
    el.mMenu?.addEventListener('click',()=>setDrawer(true));
    el.closeDrawer?.addEventListener('click',()=>setDrawer(false));
    el.overlay?.addEventListener('click',()=>setDrawer(false));

    (function moveControlsToDrawer(){
      if(!IS_MOBILE) return;
      const filesHost=el.secFiles, actionsHost=el.secActions, settingsHost=el.secSettings;
      el.audioFile?.closest('.field.audio') && filesHost?.appendChild(el.audioFile.closest('.field.audio'));
      el.refFile?.closest('.field.ref') && filesHost?.appendChild(el.refFile.closest('.field.ref'));
      el.go?.closest('.actions') && actionsHost?.appendChild(el.go.closest('.actions'));
      el.adaptiveToggle && settingsHost?.appendChild(el.adaptiveToggle.closest('label').parentElement);
      el.prog && settingsHost?.appendChild(el.prog.closest('.meter'));
    })();

    /* ========== Speed popover ========== */
    function setRate(v){
      const p=activePlayer();
      CURRENT_RATE=Math.max(0.5,Math.min(3.0,Number(v)||1));
      if(p) p.playbackRate=CURRENT_RATE;
      el.mSpeed.textContent=CURRENT_RATE.toFixed(2)+'×';
    }
    function openSpeedPopover(){
      const rect=el.mSpeed.getBoundingClientRect();
      const pop=el.speedPopover; pop.style.display='block';
      const w=pop.offsetWidth||220;
      const left=Math.min(rect.left, window.innerWidth - w - 8);
      pop.style.left=Math.round(Math.max(8,left))+'px';
      pop.style.top=Math.round(rect.bottom+8)+'px';
      el.speedInput.value=CURRENT_RATE.toFixed(2);
      const onDoc=(ev)=>{ if(!pop.contains(ev.target) && ev.target!==el.mSpeed){ closeSpeedPopover(); document.removeEventListener('mousedown',onDoc,true); } };
      document.addEventListener('mousedown',onDoc,true);
    }
    function closeSpeedPopover(){ el.speedPopover.style.display='none'; }
    el.mSpeed?.addEventListener('click',openSpeedPopover);
    el.speedApply?.addEventListener('click',()=>{ setRate(el.speedInput.value); closeSpeedPopover(); });
    document.querySelectorAll('.speedOpt').forEach(opt=>opt.addEventListener('click',()=>{ setRate(opt.dataset.sp); closeSpeedPopover(); }));

    /* ========== Times/seek ========== */
    function fmtClock(sec){ if(!isFinite(sec)) return '0:00'; const s=Math.max(0,sec|0), m=(s/60|0), ss=(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; }
    function setMobileTimes(){
      if(!IS_MOBILE) return;
      const p=activePlayer(); if(!p || !isFinite(p.duration)) return;
      el.mElapsed.textContent=fmtClock(p.currentTime);
      el.mRemain.textContent='-'+fmtClock(Math.max(0,p.duration-p.currentTime));
      el.mTotal.textContent=fmtClock(p.duration);
      if(p.duration>0) el.mSeek.value = Math.round((p.currentTime / p.duration) * 1000) || 0;
    }
    el.mSeek?.addEventListener('input',()=>{
      const p=activePlayer(); if(!p || !isFinite(p.duration)) return;
      p.currentTime = (+el.mSeek.value/1000)*p.duration;
    });

    /* ========== Model utils ========== */
    function modelWatchStart(){MODEL_WATCH.active=true;MODEL_WATCH.canceled=false;MODEL_WATCH.start=Date.now();MODEL_WATCH.lastBeat=Date.now();el.cancelModel&&(el.cancelModel.style.display='inline-flex');MODEL_WATCH.timer&&clearInterval(MODEL_WATCH.timer);MODEL_WATCH.timer=setInterval(()=>{const now=Date.now(),sinceBeat=(now-MODEL_WATCH.lastBeat)/1e3,sinceStart=(now-MODEL_WATCH.start)/1e3;sinceBeat>45&&addLog('warn','Model load appears stalled',{idle_secs:sinceBeat});sinceStart>120&&addLog('warn','Model load unusually long',{elapsed_secs:sinceStart})},5e3)}
    function modelWatchBeat(msg){MODEL_WATCH.lastBeat=Date.now();msg&&addLog('info','model: '+msg)}
    function modelWatchEnd(){MODEL_WATCH.active=false;MODEL_WATCH.timer&&(clearInterval(MODEL_WATCH.timer),MODEL_WATCH.timer=null);el.cancelModel&&(el.cancelModel.style.display='none')}
    function modelCancel(){MODEL_WATCH.canceled=true;addLog('warn','Model load cancel requested')}
    el.cancelModel && (el.cancelModel.onclick=()=>modelCancel());

    /* ========== Highlight ========== */
    function normalizeForPlayback(words){
      const out=words.map(w=>({word:w.word,start:+w.start,end:+w.end,conf:+(w.conf??1)})).filter(w=>Number.isFinite(w.start)&&Number.isFinite(w.end));
      if(!out.length) return out;
      for(let i=0;i<out.length;i++){
        const w=out[i],nextStart=i<out.length-1?out[i+1].start:w.end;
        w.end<w.start&&(w.end=w.start);
        w.end=Math.max(w.start+MIN_WORD,w.end);
        if(i<out.length-1){w.end=Math.min(w.end,nextStart-GAP_PAD);if(w.end<=w.start)w.end=Math.min(nextStart-GAP_PAD,w.start+MIN_WORD)}
      }
      for(let i=1;i<out.length;i++) if(out[i].start<out[i-1].end+GAP_PAD) out[i].start=Math.min(out[i].start,out[i-1].end+GAP_PAD);
      return out
    }
    function buildHighlightWindows(){HWIN=[];const n=PLAY_WORDS.length;if(!n)return;const C=PLAY_WORDS.map(w=>(w.start+w.end)/2);for(let i=0;i<n;i++){let L=i? (C[i-1]+C[i])/2 : (PLAY_WORDS[i].start-HILITE_LEAD),R=i===n-1? (PLAY_WORDS[i].end+HILITE_LAG):(C[i]+C[i+1])/2;i&&(L=Math.max(L,HWIN[i-1].end+1e-4));R<=L&&(R=L+1e-3);HWIN[i]={start:L,end:R}}}
    function playSegment(start,end){
      const p=activePlayer(); if(!p) return;
      try{
        const s=Math.max(0,(+start||0)-CLICK_PAD);
        let e=Math.max(s+CLICK_MIN,+end||s+CLICK_MIN);
        const dur=(p.duration&&isFinite(p.duration))?p.duration:null; dur!=null&&(e=Math.min(e,dur));
        try{!p.paused&&p.pause()}catch{}
        __playTimer&&(clearTimeout(__playTimer),__playTimer=null);
        p.currentTime=s; const pr=p.play(); pr&&pr.catch(()=>{});
        const playDur=Math.min(e-s,60); __playTimer=setTimeout(()=>{try{p.pause()}catch{}},playDur*1e3);
      }catch{}
    }
    function currentTimeAdj(){const p=activePlayer(); return p.currentTime+(ADAPTIVE_ON?driftBias:0)}
    function findWordIndexAt(t){if(!HWIN.length)return-1;let lo=0,hi=HWIN.length-1;for(;lo<=hi;){const mid=lo+hi>>1,w=HWIN[mid];if(t<w.start)hi=mid-1;else if(t>w.end)lo=mid+1;else return mid}return-1}
    function lerp(a,b,t){return a+(b-a)*t}
    function centerMobileToken(idx, progress01){
      if(!IS_MOBILE || idx<0 || !MOB_TOKENS[idx]) return;
      const cont=el.mText, tok=MOB_TOKENS[idx];
      const desired = Math.max(0, tok.offsetTop - (cont.clientHeight/2 - tok.clientHeight/2));
      cont.scrollTop = lerp(cont.scrollTop, desired, Math.min(0.35, 0.15 + progress01*0.5));
    }
    function setHighlight(i){
      if(i===CUR_HI) return;
      if(CUR_HI>=0){
        TOKENS[CUR_HI] && TOKENS[CUR_HI].classList.remove('playing');
        MOB_TOKENS[CUR_HI] && MOB_TOKENS[CUR_HI].classList.remove('playing');
      }
      CUR_HI=i;
      if(CUR_HI>=0){
        TOKENS[CUR_HI] && TOKENS[CUR_HI].classList.add('playing');
        MOB_TOKENS[CUR_HI] && MOB_TOKENS[CUR_HI].classList.add('playing');
        if(TOKENS[CUR_HI] && el.text){
          const t=TOKENS[CUR_HI], r=t.getBoundingClientRect(), host=el.text.getBoundingClientRect();
          (r.top<host.top+8||r.bottom>host.bottom-8)&&t.scrollIntoView({block:'center',inline:'nearest',behavior:'smooth'})
        }
      }
    }
    function adaptiveUpdate(idx){
      const p=activePlayer();
      if(!ADAPTIVE_ON||idx<0) return;
      const w=PLAY_WORDS[idx], mid=(w.start+w.end)/2, err=mid-p.currentTime;
      const next=driftBias*(1-DRIFT_ALPHA)+err*DRIFT_ALPHA; driftBias=Math.max(-DRIFT_CLAMP,Math.min(DRIFT_CLAMP,next))
    }
    function updateHighlightFromPlayer(){
      const p=activePlayer();
      if(IS_MOBILE) setMobileTimes();
      if(!PLAY_WORDS.length){setHighlight(-1);return}
      const t=currentTimeAdj(), idx=findWordIndexAt(t); setHighlight(idx); adaptiveUpdate(idx);
      if(IS_MOBILE && idx>=0){
        const w=PLAY_WORDS[idx];
        const prog=(t - w.start) / Math.max(1e-6,(w.end - w.start));
        centerMobileToken(idx, Math.max(0,Math.min(1,prog)));
      }

      // Chapter prefetcher (80%)
      if (CHAPTER_MODE && AUDIO_CH.length) {
        const ch=AUDIO_CH[CURRENT_AUDIO_CH_INDEX]; if(!ch) return;
        const chDur=(ch.end-ch.start);
        if(!PREFETCHING && chDur>1 && (p.currentTime - ch.start) > 0.8*chDur ){
          const nextIdx=CURRENT_AUDIO_CH_INDEX+1;
          if(nextIdx<AUDIO_CH.length) {
            PREFETCHING=true;
            const nextTextIdx = nextIdx + MAP_OFFSET;
            const refTxt = TEXT_CH[nextTextIdx]?.text || '';
            runChapter(nextIdx, false, refTxt).finally(()=>{PREFETCHING=false});
          }
        }
      }
    }
    ['timeupdate','seeked','ratechange','seeking'].forEach(ev=>{
      el.player?.addEventListener(ev,updateHighlightFromPlayer);
      el.playerDesktop?.addEventListener(ev,updateHighlightFromPlayer);
    });
    let __raf=null;function startHiLoop(){if(__raf)return;const step=()=>{updateHighlightFromPlayer();__raf=requestAnimationFrame(step)};__raf=requestAnimationFrame(step)}
    function stopHiLoop(){__raf&&(cancelAnimationFrame(__raf),__raf=null)}
    el.player?.addEventListener('play',startHiLoop);
    el.player?.addEventListener('pause',stopHiLoop);
    el.player?.addEventListener('ended',()=>{stopHiLoop();setHighlight(-1)});
    el.playerDesktop?.addEventListener('play',startHiLoop);
    el.playerDesktop?.addEventListener('pause',stopHiLoop);
    el.playerDesktop?.addEventListener('ended',()=>{stopHiLoop();setHighlight(-1)});
    el.adaptiveToggle?.addEventListener('change',()=>{ADAPTIVE_ON=!!el.adaptiveToggle.checked;ADAPTIVE_ON||(driftBias=0);addLog('info','Adaptive '+(ADAPTIVE_ON?'on':'off'),{bias:driftBias})});

    /* ========== Files ========== */
    function attachAudioFile(file){
      if(!file) return;
      AUDIO_FILE=file;
      addLog('info','Audio selected',{name:file.name,size:file.size,type:file.type});
      try{
        const url=URL.createObjectURL(file);
        const p=activePlayer(); if (p){ p.src=url; p.load(); }
        if(IS_MOBILE){ el.mTitle.textContent=file.name || 'Audio' } else { el.audioTitle && (el.audioTitle.textContent=file.name || 'Audio') }
      }catch(e){ addLog('warn','Attach audio failed',String(e)) }
      REF_TEXT=''; el.refFile && (el.refFile.value=''); ALIGNED_ONCE=false; refreshAlignButton(); addLog('info','Reference cleared for new audio');

      // parse chapters if .m4b
      AUDIO_CH=[]; CURRENT_AUDIO_CH_INDEX=0; populateAudioChapterUI();
      if (file.name.toLowerCase().endsWith('.m4b')) parseM4BChapters(file).catch(e=>addLog('warn','m4b chapters fail',String(e)));
      // decode cache for chapter slicing
      DECODE_CACHE=null;
    }
    el.audioFile && (el.audioFile.onchange=()=>attachAudioFile(el.audioFile.files?.[0]||null));

    el.refFile && (el.refFile.onchange=async()=>{
      const f=el.refFile.files?.[0]; if(!f){REF_TEXT='';ALIGNED_ONCE=false;refreshAlignButton();TEXT_CH=[];populateTextChapterUI();return}
      const name=f.name.toLowerCase();
      if(name.endsWith('.epub')){
        TEXT_CH=[]; populateTextChapterUI();
        try{ await parseEpubChapters(f); addLog('info','EPUB chapters', {count:TEXT_CH.length}); }
        catch(e){ addLog('error','EPUB parse failed', String(e)); }
        // do not set REF_TEXT here; chapter mode will pick per-chapter text
        ALIGNED_ONCE=false; refreshAlignButton();
      }else{
        try{ const txt=await f.text(); REF_TEXT=txt; addLog('info','Reference text loaded',{chars:txt.length}); TEXT_CH=[{title:f.name,text:txt,idx:0}]; populateTextChapterUI(); }
        catch(e){ addLog('error','Read ref text failed',String(e)); REF_TEXT=''; TEXT_CH=[]; populateTextChapterUI(); }
        ALIGNED_ONCE=false; refreshAlignButton();
      }
    });

    el.copy && (el.copy.onclick=async()=>{await navigator.clipboard.writeText(LOG.join(NL));addLog('info','Log copied')});
    el.save && (el.save.onclick=()=>{const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([LOG.join(NL)],{type:'text/plain'}));a.download='offline_vosk_log.txt';a.click()});

    /* ========== Vosk setup ========== */
    if (window.Vosk && Vosk.setWasmPrefix) Vosk.setWasmPrefix("https://unpkg.com/vosk-browser@0.0.8/dist/");
    if (window.Vosk && Vosk.setLogLevel) { Vosk.setLogLevel(0); }

    async function headCheck(url){ try { const r = await fetch(url, { method:"HEAD" }); return { ok:r.ok, status:r.status, len:r.headers.get("content-length"), type:r.headers.get("content-type") }; } catch(e){ return { ok:false, error:String(e) }; }
    }
    function withTimeout(promise, ms, label="operation"){ let t; const timer=new Promise((_,rej)=>t=setTimeout(()=>rej(new Error(label+" timed out")),ms)); return Promise.race([promise.finally(()=>clearTimeout(t)), timer]); }
    function destroyRecognizer(){if(RECOG){try{RECOG.remove&&RECOG.remove()}catch{}RECOG=null}}

    async function ensureModel(){
      if(typeof Vosk==='undefined'){addLog('error','Vosk not loaded');alert('Vosk failed to load');return null}
      if(MODEL) return MODEL;
      const chosen=MODEL_URL;
      setStatus(`Loading Vosk model… (${IS_MOBILE?'mobile':'desktop'})`);
      setProg(1); modelWatchStart();

      const head = await headCheck(chosen);
      if(!head.ok){
        modelWatchEnd();
        addLog('error','Model URL not reachable',{url:chosen,...head});
        alert(`Model URL not reachable (${head.status || head.error}). Check the /models path & CORS.`);
        return null;
      }
      addLog('info','Model URL preflight ok',{url:chosen,bytes:head.len,type:head.type});

      try{
        modelWatchBeat('createModel via URL');
        const t0=performance.now();
        MODEL = await withTimeout(Vosk.createModel(chosen), IS_MOBILE?150000:90000, "createModel");
        addLog('info','Model created via URL',{ms:Math.round(performance.now()-t0),url:chosen});
      }catch(e){
        modelWatchEnd();
        addLog('error','createModel(URL) failed',String(e));
        const fallback = chosen.replace(/\.(zip|tar\.gz|tgz)$/i,'/model.json');
        if(fallback!==chosen){
          const probe=await headCheck(fallback);
          if(probe.ok){
            try{
              addLog('info','Trying pre-extracted model.json',{url:fallback});
              MODEL = await withTimeout(Vosk.createModel(fallback),60000,"createModel(model.json)");
            }catch(e2){ addLog('error','Fallback model.json failed',String(e2)); }
          }
        }
      } finally { modelWatchEnd(); }

      if(MODEL_WATCH.canceled){setStatus('Model load canceled');return null}
      if(!MODEL){setStatus('Model load failed');alert('Model load failed — see Log for details.');return null}
      return MODEL;
    }

    /* ====== Decode caching (so we can slice per chapter) ====== */
    async function ensureDecode(){
      if(DECODE_CACHE && AUDIO_FILE===DECODE_CACHE.file) return DECODE_CACHE;
      if(!AUDIO_FILE) throw new Error('No audio file');
      const {f32,sr}=await decodeToMonoF32(AUDIO_FILE);
      DECODE_CACHE={f32,sr,durationSec:f32.length/sr,file:AUDIO_FILE};
      return DECODE_CACHE;
    }

    async function decodeToMonoF32(file){
      const buf=await file.arrayBuffer(),AC=window.AudioContext||window.webkitAudioContext,cx=new AC(),ab=await cx.decodeAudioData(buf),chs=ab.numberOfChannels,sr=ab.sampleRate,frames=ab.length;addLog('info','Audio decoded',{sr,chs,frames,secs:ab.duration.toFixed(3)});
      const mono=new Float32Array(frames);
      for(let c=0;c<chs;c++){const data=ab.getChannelData(c);for(let i=0;i<frames;i++)mono[i]+=data[i]/chs}
      const target=16000,res=resampleF32(mono,sr,target);addLog('info','Resampled',{from:sr,to:target,samples:res.length});await cx.close();return{f32:res,sr:target}
    }
    function resampleF32(input,src,dst){if(src===dst)return input;const ratio=dst/src,outLen=Math.round(input.length*ratio),out=new Float32Array(outLen);for(let i=0;i<outLen;i++){const x=i/ratio,xi=Math.floor(x),t=x-xi,a=input[xi]||0,b=input[xi+1]||0;out[i]=a+(b-a)*t}return out}
    function floatToInt16(f32){const i16=new Int16Array(f32.length);for(let i=0;i<f32.length;i++){let s=Math.max(-1,Math.min(1,f32[i]));i16[i]=s<0?Math.round(s*32768):Math.round(s*32767)}return i16}

    /* ========== RUN (full file or chapter slice) ========== */
    function refreshAlignButton(){
      if(!el.align) return;
      if(!REF_TEXT||!REF_TEXT.trim()){el.align.disabled=true;el.align.textContent='Align & Correct (current chapter)';el.align.title='Select a reference text to enable'}
      else{el.align.disabled=false;el.align.textContent=ALIGNED_ONCE?'Re-Align (current chapter)':'Align & Correct (current chapter)';el.align.title=ALIGNED_ONCE?'Run alignment again':'Align transcript to reference'}
    }

    async function runChapter(audioChapterIndex, makeActive=true, overrideRef=''){
      const model=await ensureModel(); if(!model) return;
      const cache=await ensureDecode();
      const ch=AUDIO_CH[audioChapterIndex] || {start:0,end:cache.durationSec,title:'Whole file'};
      const start=ch.start, end=Math.min(ch.end, cache.durationSec);
      addLog('info','Transcribing chapter', {idx:audioChapterIndex,title:ch.title,start,end});

      const sr=cache.sr, f32=cache.f32.subarray( Math.floor(start*sr), Math.floor(end*sr) );
      const i16=floatToInt16(f32);
      setStatus(`Transcribing… ${ch.title}`); setProg(12);

      destroyRecognizer();
      try{RECOG=model.KaldiRecognizer?new model.KaldiRecognizer(sr):new model.Recognizer(sr)}catch(e){addLog('error','Recognizer create failed',String(e));alert('Recognizer create failed — see log');return}
      RECOG.setWords&&RECOG.setWords(true);
      const useFloat=!!RECOG.acceptWaveformFloat;

      const fromEvents=[],transcriptPieces=[]; let lastEvt=performance.now();
      if(RECOG.on){
        RECOG.on('result',m=>{lastEvt=performance.now();let r=m;typeof r==='string'&&(()=>{try{r=JSON.parse(r)}catch{}})();const arr=r?.result?.result||r?.result||[],text=r?.result?.text||r?.text||'';text&&transcriptPieces.push(text);arr.length&&(fromEvents.push(...arr))});
        RECOG.on('finalresult',m=>{lastEvt=performance.now();let r=m;typeof r==='string'&&(()=>{try{r=JSON.parse(r)}catch{}})();const arr=r?.result?.result||r?.result||[],text=r?.result?.text||r?.text||'';text&&transcriptPieces.push(text);arr.length&&(fromEvents.push(...arr))});
      }

      const CH=Math.max(1, sr*.5|0); let off=0,n=0;
      while(off<(useFloat?f32.length:i16.length)){
        const slice=useFloat?f32.subarray(off,Math.min(f32.length,off+CH)):i16.subarray(off,Math.min(i16.length,off+CH));
        off+=CH; n++;
        try{useFloat?RECOG.acceptWaveformFloat(slice,sr):(RECOG.acceptWaveform.length===2?RECOG.acceptWaveform(slice,sr):RECOG.acceptWaveform(slice))}catch(e){addLog('error','acceptWaveform failed',String(e));break}
        n%8===0&&setProg(12+Math.min(80,Math.round(off/(useFloat?f32.length:i16.length)*80)));
        await new Promise(r=>setTimeout(r,0));
      }
      try{const tail=sr*1|0;if(useFloat){const zf=new Float32Array(tail);RECOG.acceptWaveformFloat(zf,sr)} else{const zi=new Int16Array(tail);RECOG.acceptWaveform.length===2?RECOG.acceptWaveform(zi,sr):RECOG.acceptWaveform(zi)}}catch{}

      // pull all
      const seen=[], words=[];
      const pullAll=()=>{let pulled=0;
        if(RECOG.result){for(;;){let r=RECOG.result();typeof r==='string'&&(()=>{try{r=JSON.parse(r)}catch{}})();const arr=r?.result||[],text=r?.text||'';text&&transcriptPieces.push(text);if(arr&&arr.length){arr.forEach(x=>words.push(x));pulled+=arr.length}else break}}
        if(RECOG.finalResult){let fr=RECOG.finalResult();typeof fr==='string'&&(()=>{try{fr=JSON.parse(fr)}catch{}})();const arr=fr?.result||[],text=fr?.text||'';text&&transcriptPieces.push(text);arr&&arr.length&&(arr.forEach(x=>words.push(x)),pulled+=arr.length)}
        return pulled;
      };
      for(let k=0;k<3;k++){await new Promise(r=>setTimeout(r,80));pullAll()}

      // shift times to absolute chapter start
      const shifted=words.filter(w=>w && Number.isFinite(w.start) && Number.isFinite(w.end))
        .map(w=>({word:String(w.word).trim(), start:start + +w.start, end:start + +w.end, conf:+(w.conf??1)}));

      // optional per-chapter alignment using EPUB text
      const refTxt = overrideRef || (TEXT_CH[(audioChapterIndex + MAP_OFFSET)]?.text || '');
      LAST_WORDS = shifted;
      if (refTxt && refTxt.trim()) {
        try {
          const corrected = alignAndCorrect(LAST_WORDS, refTxt);
          addLog('info','Align & Correct (chapter)',{orig:LAST_WORDS.length,corrected:corrected.length});
          LAST_WORDS = corrected; ALIGNED_ONCE=true; refreshAlignButton();
        } catch(e){ addLog('warn','Chapter align failed', String(e)); }
      }

      PLAY_WORDS=normalizeForPlayback(LAST_WORDS); buildHighlightWindows(); render(PLAY_WORDS);
      setProg(100);
      setStatus(`<span class="accent">Done</span> ${LAST_WORDS.length} words — ${ch.title}`);
      updateHighlightFromPlayer();

      if(makeActive){
        CURRENT_AUDIO_CH_INDEX=audioChapterIndex;
        const p=activePlayer();
        p.currentTime = ch.start;
        p.playbackRate = CURRENT_RATE;
        p.play().catch(()=>{});
      }
    }

    async function run(){ // fallback: whole file
      LOG.length=0; el.log && (el.log.textContent='(log starts here)');
      el.text && (el.text.textContent='(no transcript yet)'); el.tb && (el.tb.innerHTML='');
      el.mText && (el.mText.textContent='(no transcript yet)');
      setProg(0);
      if(!AUDIO_FILE){alert('Choose an audio file (hamburger ▶ Files).');setDrawer(true);return}
      if (CHAPTER_MODE && AUDIO_CH.length){
        const textIdx = CURRENT_AUDIO_CH_INDEX + MAP_OFFSET;
        const refTxt = TEXT_CH[textIdx]?.text || '';
        return runChapter(CURRENT_AUDIO_CH_INDEX, true, refTxt);
      }
      return runChapter(0,true,'');
    }

    /* ===== Align helpers ===== */
    function normalizeToken(s){return String(s).toLowerCase().replace(/[^a-z]+/g,'')}
    function tokenizeReference(text){return text.split(/\s+/).filter(Boolean).map(tok=>{const norm=normalizeToken(tok);return norm?{raw:tok,norm}:null}).filter(Boolean)}
    function levenshtein(a,b){const m=a.length,n=b.length,dp=new Array(n+1);for(let j=0;j<=n;j++)dp[j]=j;for(let i=1;i<=m;i++){let prev=dp[0];dp[0]=i;for(let j=1;j<=n;j++){const ins=dp[j]+1,del=dp[j-1]+1,sub=prev+(a[i-1]===b[j-1]?0:1);prev=dp[j];dp[j]=Math.min(ins,del,sub)}}return dp[n]}
    function sim(a,b){if(!a.length&&!b.length)return 1;const d=levenshtein(a,b);return 1-d/Math.max(1,Math.max(a.length,b.length))}
    function joinNorm(arr){return arr.map(x=>normalizeToken(typeof x==='string'?x:x.word||x.raw||'')).join('')}
    function alignAndCorrect(hypWords,refText){
      const ref=tokenizeReference(refText),hyp=hypWords.map(w=>({raw:w.word,norm:normalizeToken(w.word),start:w.start,end:w.end,conf:w.conf}));
      const n=hyp.length,m=ref.length,H=3,R=3,BIG=1e9,PEN_GROUP=.005,PEN_SIZE=.01;
      function score(i1,i2,j1,j2){const hg=hyp.slice(i1,i2),rg=ref.slice(j1,j2),hj=joinNorm(hg),rj=rg.map(x=>x.norm).join(''),base=1-sim(hj,rj),pen=PEN_GROUP*(hg.length+rg.length-2)+PEN_SIZE*Math.abs(hg.length-rg.length);return base+pen}
      const dp=Array.from({length:n+1},()=>Array(m+1).fill(BIG)),back=Array.from({length:n+1},()=>Array(m+1).fill(null));dp[0][0]=0;
      for(let i=0;i<=n;i++)for(let j=0;j<=m;j++){const cur=dp[i][j];if(cur===BIG)continue;for(let hi=1;hi<=H&&i+hi<=n;hi++)for(let rj=1;rj<=R&&j+rj<=m;rj++){const c=score(i,i+hi,j,j+rj),nc=cur+c;if(nc<dp[i+hi][j+rj]){dp[i+hi][j+rj]=nc;back[i+hi][j+rj]={i0:i,j0:j,hi,rj}}}}
      const groups=[];if(back[n][m]==null){let i=0,j=0;while(i<n&&j<m){groups.push({i0:i,j0:j,hi:1,rj:1});i++;j++}}else{let i=n,j=m;while(i>0&&j>0){const b=back[i][j];groups.push(b);i=b.i0;j=b.j0}groups.reverse()}
      const out=[];let prevEnd=null;
      for(const g of groups){
        const hypG=hyp.slice(g.i0,g.i0+g.hi),refG=ref.slice(g.j0,g.j0+g.rj);
        let gStart=Math.min(...hypG.map(t=>t.start)),gEnd=Math.max(...hypG.map(t=>t.end));
        if(prevEnd!=null&&gStart<prevEnd){gStart=prevEnd;gEnd<gStart&&(gEnd=gStart)}
        if(g.rj===1){out.push({word:refG[0].raw,start:gStart,end:gEnd,conf:1})}
        else if(g.hi===1){const total=refG.reduce((a,b)=>a+b.norm.length,0)||g.rj;let cur=gStart;for(let idx=0;idx<refG.length;idx++){const rr=refG[idx],frac=(rr.norm.length||1)/total;let next=idx===refG.length-1?gEnd:Math.min(gEnd,cur+frac*(gEnd-gStart));out.push({word:rr.raw,start:cur,end:next,conf:1});cur=next}}
        else{const step=(gEnd-gStart)/g.rj||0;for(let k=0;k<g.rj;k++){const a=gStart+k*step,b=k===g.rj-1?gEnd:gStart+(k+1)*step;out.push({word:refG[k].raw,start:a,end:b,conf:1})}}
        prevEnd=out[out.length-1].end
      }
      const produced=groups.reduce((s,g)=>s+g.rj,0);
      if(produced<ref.length){let cur=prevEnd??0;for(let j=produced;j<ref.length;j++){const w=ref[j];out.push({word:w.raw,start:cur,end:cur+.25,conf:.5});cur+=.25}}
      return out
    }

    function fmt(t){if(!isFinite(t))return'';const s=t|0,ms=Math.round((t-(t|0))*1e3).toString().padStart(3,'0'),m=(s/60|0).toString().padStart(2,'0'),ss=(s%60).toString().padStart(2,'0');return`${m}:${ss}.${ms}`}
    function escapeHtml(s){return String(s).replace(/[&<>"]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]))}

    function render(words){
      // desktop
      if(el.text){ const cont=el.text,tb=el.tb; cont.innerHTML=''; tb && (tb.innerHTML=''); TOKENS=[]; CUR_HI=-1;
        if(!words.length){cont.textContent='(empty)'} else {
          const frag=document.createDocumentFragment();
          words.forEach((w,i)=>{i&&frag.append(' ');const sp=document.createElement('span');sp.className='token';sp.dataset.idx=String(i);sp.textContent=w.word;sp.title=`${fmt(w.start)} → ${fmt(w.end)} (conf ${(w.conf??0).toFixed(2)}) — click to play`;frag.append(sp)});
          cont.append(frag); TOKENS=Array.from(cont.querySelectorAll('.token'));
          if(tb){const rows=document.createDocumentFragment();
            words.forEach((w,i)=>{const tr=document.createElement('tr');tr.innerHTML=`<td class="play"><button class="playbtn" data-idx="${i}" title="Play word">▶</button></td><td>${i+1}</td><td>${escapeHtml(w.word)}</td><td class="mobile-hide">${fmt(w.start)}</td><td class="mobile-hide">${fmt(w.end)}</td><td class="mobile-hide">${(w.conf??0).toFixed(2)}</td>`;rows.append(tr)});
            tb.append(rows)
          }
        }
      }
      // mobile 3-line viewport
      if(el.mText){
        const m=el.mText; m.innerHTML=''; MOB_TOKENS=[];
        if(!words.length){m.textContent='(empty)'} else {
          const frag2=document.createDocumentFragment();
          words.forEach((w,i)=>{i&&frag2.append(' ');const sp=document.createElement('span');sp.className='token';sp.dataset.idx=String(i);sp.textContent=w.word;frag2.append(sp)});
          m.append(frag2); MOB_TOKENS=Array.from(m.querySelectorAll('.token'));
        }
        if (AUDIO_CH.length) {
          const ch=AUDIO_CH[CURRENT_AUDIO_CH_INDEX];
          el.mChapterIdx.textContent=String(CURRENT_AUDIO_CH_INDEX+1).padStart(3,'0');
          el.mChapterClock.textContent=fmt(ch.start).slice(0,5);
          el.mChapterLen.textContent=fmt(ch.end-ch.start).slice(0,5);
        }
      }
      addLog('info','Rendered',{words:words.length})
    }

    el.text?.addEventListener('click',ev=>{const t=ev.target.closest('.token');if(!t)return;const idx=+t.dataset.idx,w=PLAY_WORDS[idx];if(!w)return;playSegment(w.start,w.end)});
    el.tb?.addEventListener('click',ev=>{const b=ev.target.closest('.playbtn');if(!b)return;const idx=+b.dataset.idx,w=PLAY_WORDS[idx];if(!w)return;playSegment(w.start,w.end)});
    el.mText?.addEventListener('click',ev=>{const t=ev.target.closest('.token');if(!t)return;const idx=+t.dataset.idx,w=PLAY_WORDS[idx];if(!w)return;playSegment(w.start,w.end)});

    /* ========== Chapters UI ========== */
    function populateAudioChapterUI(){
      const sel=el.audioChSel; sel.innerHTML='';
      if(!AUDIO_CH.length){el.audioChMeta.textContent='(no audio chapters)'; return;}
      AUDIO_CH.forEach((c,i)=>{const o=document.createElement('option');o.value=i;o.textContent=`${(i+1).toString().padStart(3,'0')}  ${c.title}  (${fmt(c.start).slice(0,5)}–${fmt(c.end).slice(0,5)})`; sel.appendChild(o)});
      el.audioChMeta.textContent=`${AUDIO_CH.length} audio chapters`;
    }
    function populateTextChapterUI(){
      const sel=el.textChSel; sel.innerHTML='';
      if(!TEXT_CH.length){el.textChMeta.textContent='(no text chapters)'; return;}
      TEXT_CH.forEach((c,i)=>{const o=document.createElement('option');o.value=i;o.textContent=`${(i+1).toString().padStart(3,'0')}  ${c.title}`; sel.appendChild(o)});
      el.textChMeta.textContent=`${TEXT_CH.length} text chapters`;
    }
    function updateMapInfo(){
      const a=+el.mapAudioIdx.value|0, t=+el.mapTextIdx.value|0;
      MAP_OFFSET = t - a;
      el.mapInfo.textContent=`Offset = textStart - audioStart = ${MAP_OFFSET}`;
    }
    el.applyMap?.addEventListener('click',updateMapInfo);
    el.startChapterMode?.addEventListener('click',()=>{
      CHAPTER_MODE=true;
      CURRENT_AUDIO_CH_INDEX = Math.max(0, +el.mapAudioIdx.value|0);
      const p=activePlayer();
      if (AUDIO_CH.length){
        const ch=AUDIO_CH[CURRENT_AUDIO_CH_INDEX];
        p.currentTime=ch.start;
        p.playbackRate=CURRENT_RATE;
        p.play().catch(()=>{});
        const refTxt = TEXT_CH[CURRENT_AUDIO_CH_INDEX + MAP_OFFSET]?.text || '';
        runChapter(CURRENT_AUDIO_CH_INDEX,false,refTxt).catch(()=>{});
      } else {
        alert('No audio chapters loaded');
      }
    });
    el.transcribeThisChapter?.addEventListener('click',()=>{
      const idx = +el.audioChSel.value|0;
      if(Number.isFinite(idx)){ CURRENT_AUDIO_CH_INDEX=idx; const refTxt=TEXT_CH[idx + MAP_OFFSET]?.text || ''; runChapter(idx,true,refTxt); }
    });
    el.audioChSel?.addEventListener('change',()=>{ const idx=+el.audioChSel.value|0; el.mapAudioIdx.value=idx; updateMapInfo(); });
    el.textChSel?.addEventListener('change',()=>{ const idx=+el.textChSel.value|0; el.mapTextIdx.value=idx; updateMapInfo(); });

    /* ========== m4b chapter parsing (mp4box) ========== */
    async function parseM4BChapters(file){
      addLog('info','Parsing m4b chapters…');
      const mp4boxfile = MP4Box.createFile();
      const buf = await file.arrayBuffer();
      const arrayBuffer = buf.slice(0); arrayBuffer.fileStart = 0;
      const chapters=[];
      mp4boxfile.onReady = info => {
        // try to find a text track that acts like a chapter track
        let timescale = info.timescale || 1000;
        if(info.tracks && info.tracks.length){
          info.tracks.forEach(tr=>{
            if(tr.kind && /chap/i.test(tr.kind.schemeURI||'') || (tr.codec && /text|tx3g|wvtt|stpp/i.test(tr.codec))) {
              const s = tr.samples || [];
              for(const smp of s){
                const start = smp.dts / tr.timescale;
                const end = (smp.dts + smp.duration) / tr.timescale;
                const title = (smp.text || smp.data || smp.description || '').toString().trim() || `Chapter ${chapters.length+1}`;
                chapters.push({title, start, end});
              }
            }
          });
        }
        // Fallback: QuickTime "chap" or udta (not always surfaced by mp4box) – we’ll at least set a single chapter whole file if none
        if(!chapters.length){
          const dur = (info.duration || 0) / (info.timescale||1000);
          chapters.push({title:file.name, start:0, end:dur||999999});
        }
      };
      mp4boxfile.appendBuffer(arrayBuffer);
      mp4boxfile.flush();
      // Normalize/close gaps and ensure sequential
      chapters.sort((a,b)=>a.start-b.start);
      for(let i=0;i<chapters.length;i++){
        if(i<chapters.length-1) chapters[i].end = Math.min(chapters[i].end, chapters[i+1].start);
        if(chapters[i].end <= chapters[i].start) chapters[i].end = chapters[i].start + 0.5;
      }
      AUDIO_CH = chapters;
      populateAudioChapterUI();
      addLog('info','m4b chapters parsed',{count:chapters.length});
    }

    /* ========== EPUB parsing (epub.js) ========== */
    async function parseEpubChapters(file){
      addLog('info','Parsing EPUB…');
      const url=URL.createObjectURL(file);
      const book = ePub(url);
      await book.ready;
      const nav = await book.loaded.navigation;
      const toc = (nav && nav.toc) ? nav.toc : [];
      // flatten toc (one level)
      const items=[];
      function walk(arr){ arr.forEach(n=>{ items.push(n); if(n.subitems) walk(n.subitems); }) }
      walk(toc);

      async function itemText(href){
        try{
          const res = await book.resources.get(href);
          if(!res) return '';
          const html = await res.text();
          const div = document.createElement('div'); div.innerHTML = html;
          // remove scripts/styles
          div.querySelectorAll('script,style,noscript').forEach(n=>n.remove());
          return (div.textContent || '').replace(/\s+/g,' ').trim();
        }catch{ return '' }
      }

      const out=[];
      for(let i=0;i<items.length;i++){
        const it=items[i], title=(it.label||it.id||`Chapter ${i+1}`).toString();
        const text=await itemText(it.href||it.hrefs||it.url||'');
        out.push({title, text, idx:i});
      }
      TEXT_CH = out.filter(x=>x.text && x.text.length>0);
      populateTextChapterUI();
    }

    /* ========== Init & wire buttons ========== */
    addLog('info','Ready. Auto-detecting model in background (no model UI).');
    addLog('info','Env',{ua:navigator.userAgent,deviceMemory:navigator.deviceMemory||null});
    el.go && (el.go.onclick=()=>run().catch(e=>addLog('error','Top level failure',String(e))));
    el.align && (el.align.onclick=()=>{try{if(!LAST_WORDS.length){alert('Transcribe first');return}const refTxt= (CHAPTER_MODE && TEXT_CH[(CURRENT_AUDIO_CH_INDEX+MAP_OFFSET)]?.text) || REF_TEXT || '';if(!refTxt){alert('Load an EPUB or TXT to align against.');return}const corrected=alignAndCorrect(LAST_WORDS,refTxt);addLog('info','Alignment complete',{orig:LAST_WORDS.length,corrected:corrected.length});LAST_WORDS=corrected;PLAY_WORDS=normalizeForPlayback(LAST_WORDS);buildHighlightWindows();render(PLAY_WORDS);updateHighlightFromPlayer();ALIGNED_ONCE=true;refreshAlignButton()}catch(e){addLog('error','Align failed',String(e));alert('Align failed — see log')}});
    refreshAlignButton();

    if(IS_MOBILE){
      const p=activePlayer();
      el.mPrev&&(el.mPrev.onclick=()=>{p.currentTime=Math.max(0,p.currentTime-10)});
      el.mNext&&(el.mNext.onclick=()=>{if(isFinite(p.duration)) p.currentTime=Math.min(p.duration,p.currentTime+10)});
      el.mPlay&&(el.mPlay.onclick=()=>{p.paused?p.play():p.pause(); el.mPlay.textContent=p.paused?'▶':'⏸'});
      p.addEventListener('play',()=>{ el.mPlay.textContent='⏸'; setRate(CURRENT_RATE); });
      p.addEventListener('pause',()=>{ el.mPlay.textContent='▶'; });
    }

    // Keep the speed pill in sync on first load
    setRate(CURRENT_RATE);

    // Show initial mapping info
    updateMapInfo();

    // Auto-advance to next chapter when a chapter finishes (chapter mode)
    function advanceOnEnd(){
      if (!CHAPTER_MODE || !AUDIO_CH.length) return;
      const next = CURRENT_AUDIO_CH_INDEX + 1;
      if (next < AUDIO_CH.length) {
        const refTxt = TEXT_CH[next + MAP_OFFSET]?.text || '';
        runChapter(next, true, refTxt).catch(()=>{});
      }
    }
    el.player?.addEventListener('ended', advanceOnEnd);
    el.playerDesktop?.addEventListener('ended', advanceOnEnd);

    // Lightweight self-checks
    (function(){
      const samp=resampleF32(new Float32Array([0,1,0,-1]),4,8);
      console.assert(samp.length===8,'resample length');
      console.assert(fmt(61.005)==='01:01.005','fmt time');
    })();
  </script>
</body>
</html>
