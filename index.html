<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Offline Transcriber — Vosk (WASM)</title>
  <style>
    :root{
      --bg:#111418;--panel:#161b21;--fg:#e8eef7;--muted:#9aa6b2;--line:#273044;--accent:#ffd666;
      --mobile-max:420px; --m-lines:3; --m-lh:1.6;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,Segoe UI,Arial,sans-serif;overflow-x:hidden}

    header{display:grid;gap:10px;align-items:center;padding:12px;background:var(--panel);position:sticky;top:0;z-index:5;border-bottom:1px solid var(--line);grid-template-columns:repeat(12,minmax(0,1fr))}
    .field{display:flex;flex-direction:column;gap:6px}.field .lbl{font-size:12px;color:var(--muted)}
    header .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    header .meter{display:flex;gap:10px;align-items:center;justify-content:flex-end}
    header .opts{display:flex;gap:16px;align-items:center}
    header .field.audio{grid-column:span 4}header .field.ref{grid-column:span 4}
    header .actions{grid-column:span 4}header .opts{grid-column:span 6}header .meter{grid-column:span 6}
    header .playerRow{grid-column:1/-1}
    button,input,select{background:#1e2430;border:1px solid #2b3342;color:var(--fg);border-radius:10px;padding:10px 12px}
    button:hover{filter:brightness(1.06)}button:disabled{opacity:.5;cursor:not-allowed;filter:none}
    button.primary{background:var(--accent);color:#000;border-color:transparent}
    button.danger{background:#ff6b6b;color:#000;border-color:#ff9e9e}
    progress{height:12px;width:240px}
    #playerDesktop{width:100%;height:42px;background:#0f131a;border-radius:10px}

    #grid{display:grid;grid-template-columns:2fr 1fr;gap:12px;padding:12px}
    .pane{border:1px solid var(--line);border-radius:10px;overflow:auto}
    .pane .ttl{padding:8px 12px;border-bottom:1px solid var(--line);background:#131821;position:sticky;top:0}
    #text{padding:12px;white-space:pre-wrap}
    .token{padding:2px 3px;border-radius:6px;cursor:pointer}.token:hover{background:#1e2733}.token.playing{background:var(--accent);color:#000}
    small{color:var(--muted)}.accent{background:var(--accent);color:#000;border-radius:6px;padding:0 5px}
    #log{font:12px/1.3 ui-monospace,Consolas,monospace;white-space:pre-wrap;padding:10px}.ok{color:#baffc1}.warn{color:#ffe9a6}.bad{color:#ffb4b4}
    #tbl{width:100%;border-collapse:collapse}#tbl th,#tbl td{border-bottom:1px solid #273044;padding:6px 8px;text-align:left;font-variant-numeric:tabular-nums}
    #tbl th.play,#tbl td.play{width:48px}.playbtn{cursor:pointer;border:1px solid #2b3342;background:#1e2430;border-radius:6px;padding:2px 6px}.playbtn:hover{filter:brightness(1.1)}
    .row{display:flex;gap:10px;align-items:center;padding:10px;border-top:1px solid var(--line);background:#131821}

    @media (max-width:1100px){header .field.audio,header .field.ref{grid-column:span 6}header .actions{grid-column:span 6}header .opts{grid-column:span 6}header .meter{grid-column:span 6}}
    @media (max-width:820px){#grid{grid-template-columns:1fr}}
    @media (max-width:720px){header{grid-template-columns:repeat(6,minmax(0,1fr))}header .field.audio,header .field.ref,header .actions,header .opts,header .meter{grid-column:1/-1}progress{width:100%}}

    .topbar{grid-column:1/-1;display:flex;align-items:center;gap:12px}.topbar .title{font-weight:600}

    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.45);backdrop-filter:saturate(120%) blur(2px);z-index:40}

    .drawer{position:fixed;inset:0 auto 0 0;width:82%;max-width:520px;background:var(--panel);border-right:1px solid var(--line);transform:translateX(-105%);transition:transform .18s ease-out;z-index:50;display:flex;flex-direction:column}
    .drawer.open{transform:translateX(0)}
    .drawer-head{display:flex;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid var(--line)}
    .drawer-title{font-weight:600}
    .xbtn{background:#1e2430;border:1px solid #2b3342;color:var(--fg);border-radius:10px;padding:8px 10px}
    .drawer-body{padding:12px;display:grid;gap:12px}
    .drawer .sec{display:grid;gap:8px}
    .drawer .sec .sec-title{font-size:12px;color:var(--muted);margin:4px 0 2px}

    :root[data-mobile="1"] body{font-size:16px}
    :root[data-mobile="1"] header{display:none}
    :root[data-mobile="0"] #mobileApp{display:none}

    #mobileApp{display:grid;grid-template-rows:auto auto 1fr auto;gap:16px;padding:14px;width:100%;max-width:var(--mobile-max);margin:0 auto}
    #mBar{display:flex;align-items:center;gap:10px}
    #mMenu{width:42px;height:42px;border-radius:10px;border:1px solid #2b3342;background:#1e2430;display:flex;align-items:center;justify-content:center}
    #mMenu span{display:block;width:18px;height:2px;background:var(--fg);position:relative}
    #mMenu span::before,#mMenu span::after{content:"";position:absolute;left:0;width:18px;height:2px;background:var(--fg)}
    #mMenu span::before{top:-6px}#mMenu span::after{top:6px}
    #mTitle{font-size:24px;font-weight:800;flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    #mTimes{display:flex;justify-content:space-between;font-variant-numeric:tabular-nums}
    #mSeek{appearance:none;width:100%;height:20px;border-radius:10px;background:#0f131a;border:1px solid #273044;outline:none}
    #mSeek::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);border:none}
    #mSeek::-moz-range-thumb{width:18px;height:18px;border:none;border-radius:50%;background:var(--accent)}

    #mViewport{border:1px solid var(--line);border-radius:12px;background:#cfd3da0a;padding:10px 12px;overflow:hidden;position:relative}
    #mText{line-height:var(--m-lh);white-space:pre-wrap;overflow:auto;height:calc(var(--m-lh) * 1em * var(--m-lines) + 12px);scrollbar-width:none;word-break:break-word;overflow-wrap:break-word}
    #mText::-webkit-scrollbar{display:none}
    #mText .token{padding:4px 6px;border-radius:8px}
    #mText .token.playing{background:var(--accent);color:#000}

    #mChapterRow{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;align-items:center}
    .mChip{font-size:18px;text-align:center;border:1px solid var(--line);border-radius:10px;padding:8px 10px;background:#1a1f28}

    #mTransport{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
    .mBtn{display:flex;align-items:center;justify-content:center;border-radius:16px;padding:18px;border:1px solid #2b3342;background:#1e2430;font-size:24px}
    .mBtn:active{transform:scale(.98)}
    #mBottom{display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin-top:2px}
    #mBottom .pill{display:flex;align-items:center;justify-content:center;border:1px solid var(--line);border-radius:12px;padding:10px 8px;background:#141923}

    #speedPopover{position:fixed;z-index:60;min-width:220px;border:1px solid #2b3342;background:#0f131a;border-radius:12px;padding:10px;display:none;box-shadow:0 6px 20px rgba(0,0,0,.45)}
    #speedPopover .row{display:flex;gap:8px;flex-wrap:wrap}
    .speedOpt{flex:1;border:1px solid #2b3342;background:#1e2430;border-radius:10px;padding:8px 10px;text-align:center;cursor:pointer}
    .speedOpt:hover{filter:brightness(1.07)}
    .speedCustom{display:flex;gap:8px;margin-top:8px}
    .speedCustom input{flex:1;text-align:center}
    .speedCustom button{padding:10px 12px}

    :root[data-mobile="1"] #grid{display:none}
  </style>

  <script>
    (function(){
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent||'')
        || (window.matchMedia && matchMedia('(pointer:coarse)').matches)
        || (typeof window!=='undefined' && window.innerWidth<=768);
      document.documentElement.setAttribute('data-mobile',isMobile?'1':'0');
    })();
  </script>
  <script>
  // --- START: robust FFmpeg loader (UMD) ---
  async function loadScript(src, timeoutMs = 12000) {
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      const timer = setTimeout(() => { s.remove(); reject(new Error('timeout')); }, timeoutMs);
      s.onload = () => { clearTimeout(timer); resolve(); };
      s.onerror = (e) => { clearTimeout(timer); reject(e?.error || new Error('network error')); };
      s.src = src; s.async = true;
      document.head.appendChild(s);
    });
  }
  
  // Preferred sources for @ffmpeg/ffmpeg UMD
  const FFMPEG_UMD_CANDIDATES = [
    'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.10/umd/ffmpeg.min.js',   // ✅ has .min.js
    'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js',    // (non-min) fallback
    'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js',               // (non-min) fallback
    `${location.origin}/AudTextSync/ffmpeg/ffmpeg.min.js`,                        // your Pages copy (if published)
  ];
  
  async function ensureFFmpegUMD() {
    if (window.FFmpeg) return window.FFmpeg;
    for (const url of FFMPEG_UMD_CANDIDATES) {
      try { await loadScript(url, 12000); if (window.FFmpeg) return window.FFmpeg; }
      catch (err) { console.warn('[FFmpeg] script failed', { url, err: String(err) }); }
    }
    throw new Error('FFmpeg UMD script could not be loaded from any source');
  }
  
  async function getFfmpegInstance() {
    const { FFmpeg } = await ensureFFmpegUMD();
    const ffmpeg = new FFmpeg();
    // Use explicit UMD-core URLs so the worker/wasm always resolve
    await ffmpeg.load({
      coreURL:   'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg-core/0.12.10/umd/ffmpeg-core.js',
      wasmURL:   'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg-core/0.12.10/umd/ffmpeg-core.wasm',
      workerURL: 'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg-core/0.12.10/umd/ffmpeg-core.worker.js',
    });
    return ffmpeg;
  }
  // --- END: robust FFmpeg loader (UMD) ---
  </script>
</head>
<body>

  <!-- ===== MOBILE SHELL ===== -->
  <main id="mobileApp">
    <div id="mBar">
      <button id="mMenu" aria-label="Open menu"><span></span></button>
      <div id="mTitle">No audio loaded</div>
    </div>

    <section>
      <div id="mTimes">
        <div id="mElapsed">0:00</div>
        <div id="mRemain">-0:00</div>
        <div id="mTotal">0:00</div>
      </div>
      <input id="mSeek" type="range" min="0" max="1000" step="1" value="0" />
    </section>

    <section id="mViewport"><div id="mText">(no transcript yet)</div></section>

    <section id="mChapterRow">
      <div id="mChapterIdx" class="mChip">—</div>
      <div id="mChapterClock" class="mChip">—</div>
      <div id="mChapterLen" class="mChip">—</div>
    </section>

    <section id="mTransport">
      <button id="mPrev" class="mBtn" title="Back 10s">⏮</button>
      <button id="mPlay" class="mBtn" title="Play/Pause">▶</button>
      <button id="mNext" class="mBtn" title="Forward 10s">⏭</button>
    </section>

    <section id="mBottom">
      <div class="pill" id="mRB">RB</div>
      <div class="pill" id="mSpeed">1.00×</div>
      <div class="pill" id="mVol">V ±</div>
      <div class="pill" id="mDP">DP</div>
      <div class="pill" id="mMore">⋯</div>
    </section>

    <audio id="player" hidden></audio>
  </main>

  <div id="speedPopover" role="dialog" aria-label="Playback speed">
    <div class="row">
      <div class="speedOpt" data-sp="0.75">0.75×</div><div class="speedOpt" data-sp="0.90">0.90×</div>
      <div class="speedOpt" data-sp="1.00">1.00×</div><div class="speedOpt" data-sp="1.10">1.10×</div>
      <div class="speedOpt" data-sp="1.20">1.20×</div><div class="speedOpt" data-sp="1.25">1.25×</div>
      <div class="speedOpt" data-sp="1.50">1.50×</div><div class="speedOpt" data-sp="1.55">1.55×</div>
      <div class="speedOpt" data-sp="2.00">2.00×</div>
    </div>
    <div class="speedCustom">
      <input id="speedInput" type="number" step="0.01" min="0.50" max="3.00" placeholder="Custom (e.g. 1.55)" />
      <button id="speedApply" class="primary">Apply</button>
    </div>
  </div>

  <!-- ===== DESKTOP UI ===== -->
  <header>
    <div class="topbar">
      <div id="audioTitle" class="title">No audio loaded</div>
      <!-- NEW: open drawer on desktop -->
      <button id="openDrawerDesktop" class="xbtn" aria-label="Open menu">Menu</button>
    </div>

    <div id="controlShelf">
      <div class="field audio">
        <div class="lbl">Audio</div>
        <input id="audioFile" type="file" accept="audio/*,.m4b" />
      </div>
      <div class="field ref">
        <div class="lbl">Reference Text (optional)</div>
        <input id="refFile" type="file" accept=".txt,.epub,text/plain,application/epub+zip" />
      </div>
      <div class="actions">
        <button id="go" class="primary">Transcribe (current chapter)</button>
        <button id="align">Align &amp; Correct (current chapter)</button>
      </div>
      <div class="opts">
        <label style="display:flex;gap:8px;align-items:center">
          <input id="adaptiveToggle" type="checkbox"/><span class="lbl">Adaptive sync (experimental)</span>
        </label>
      </div>
      <div class="meter">
        <progress id="prog" max="100" value="0"></progress>
        <button id="cancelModel" class="danger" style="display:none">Cancel</button>
        <span id="status"><small>Ready</small></span>
      </div>
    </div>

    <div class="playerRow"><audio id="playerDesktop" controls></audio></div>
  </header>

  <div id="overlay" class="overlay" hidden></div>
  <aside id="drawer" class="drawer" aria-hidden="true" aria-label="Menu">
    <div class="drawer-head">
      <div class="drawer-title">Menu</div>
      <button id="closeDrawer" class="xbtn" aria-label="Close">✕</button>
    </div>
    <div id="drawerControls" class="drawer-body">
      <div class="sec" id="secFiles"><div class="sec-title">Files</div></div>

      <div class="sec" id="secChapters">
        <div class="sec-title">Chapter Mode</div>
        <div style="display:grid;gap:8px">
          <div>
            <div class="lbl">Audio chapters (.m4b)</div>
            <select id="audioChSel" size="8" style="width:100%"></select>
            <small id="audioChMeta" style="display:block;margin-top:4px;color:var(--muted)">(no audio chapters)</small>
          </div>
          <div>
            <div class="lbl">Text chapters (.epub)</div>
            <select id="textChSel" size="8" style="width:100%"></select>
            <small id="textChMeta" style="display:block;margin-top:4px;color:var(--muted)">(no text chapters)</small>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <label class="lbl">Start at audio:</label>
            <input id="mapAudioIdx" type="number" min="0" step="1" value="0" style="width:80px">
            <label class="lbl">maps to text:</label>
            <input id="mapTextIdx" type="number" min="0" step="1" value="0" style="width:80px">
            <button id="applyMap">Apply</button>
          </div>
          <small id="mapInfo" style="color:var(--muted)">Offset = textStart - audioStart = 0</small>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button id="startChapterMode" class="primary">Start Chapter Mode</button>
            <button id="transcribeThisChapter">Transcribe Selected</button>
            <button id="exportWav" title="Download current chapter as WAV">Export WAV</button>
            <button id="sliceReplaceWav" title="Slice current chapter to a WAV and make it the active audio">
              Slice → Use WAV
            </button>
            <small id="sliceMeta" style="color:var(--muted)"></small>
          </div>
        </div>
      </div>

      <div class="sec" id="secActions"><div class="sec-title">Actions</div></div>

      <!-- NEW: Mobile-visible log inside the drawer -->
      <div class="sec" id="secLog">
        <div class="sec-title">Log</div>
        <div id="mLog"
             style="font:12px/1.3 ui-monospace,Consolas,monospace;white-space:pre-wrap;max-height:160px;overflow:auto;border:1px solid var(--line);border-radius:8px;padding:8px;background:#0f131a;">
        </div>
      </div>

      <div class="sec" id="secSettings"><div class="sec-title">Settings</div></div>
    </div>
  </aside>

  <div id="grid">
    <section class="pane">
      <div class="ttl">Transcript</div>
      <div id="text">(no transcript yet)</div>
      <div class="ttl">Per-word timestamps</div>
      <table id="tbl">
        <thead><tr><th class="play">▶</th><th>#</th><th>word</th><th class="mobile-hide">start</th><th class="mobile-hide">end</th><th class="mobile-hide">conf</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section class="pane">
      <div class="ttl">Log</div>
      <div id="log">(log starts here)</div>
      <div class="row">
        <button id="copy">Copy log</button>
        <button id="save">Download log</button>
        <div class="sp"></div>
        <small>Runs fully <span class="accent">offline</span> in your browser using Vosk WASM.</small>
      </div>
    </section>
  </div>

  <!-- deps -->
  <script src="https://unpkg.com/fflate@0.8.2/umd/index.js"></script>
  <script src="https://unpkg.com/vosk-browser@0.0.8/dist/vosk.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    /* ===================== Crash guard to Log ===================== */
    window.addEventListener('error', e => {
      const log=document.getElementById('log');
      if (log){
        const d=document.createElement('div');
        d.className='bad';
        d.textContent='[JS ERROR] '+(e.message||e.error||'unknown');
        log.appendChild(d);
      }
      const mob=document.getElementById('mLog');
      if (mob){
        const d2=document.createElement('div');
        d2.className='bad';
        d2.textContent='[JS ERROR] '+(e.message||e.error||'unknown');
        mob.appendChild(d2);
      }
      console.error(e);
    });

    /* ===================== Refs & state ===================== */
    const $=id=>document.getElementById(id);
    const el={
      audioFile:$("audioFile"),refFile:$("refFile"),
      go:$("go"),align:$("align"),
      prog:$("prog"),status:$("status"),log:$("log"),
      text:$("text"),tb:$("tbl")?.querySelector('tbody'),
      copy:$("copy"),save:$("save"),playerDesktop:$("playerDesktop"),
      adaptiveToggle:$("adaptiveToggle"),audioTitle:$("audioTitle"),
      cancelModel:$("cancelModel"),
      mobileApp:$("mobileApp"), mTitle:$("mTitle"), mSeek:$("mSeek"),
      mElapsed:$("mElapsed"), mRemain:$("mRemain"), mTotal:$("mTotal"),
      mText:$("mText"), mPrev:$("mPrev"), mPlay:$("mPlay"), mNext:$("mNext"),
      mChapterIdx:$("mChapterIdx"), mChapterClock:$("mChapterClock"), mChapterLen:$("mChapterLen"),
      mSpeed:$("mSpeed"), mMenu:$("mMenu"),
      speedPopover:$("speedPopover"), speedInput:$("speedInput"), speedApply:$("speedApply"),
      drawer:$("drawer"), overlay:$("overlay"), secFiles:$("secFiles"), secActions:$("secActions"), secSettings:$("secSettings"), closeDrawer:$("closeDrawer"),
      secChapters:$("secChapters"),
      audioChSel:$("audioChSel"), textChSel:$("textChSel"), audioChMeta:$("audioChMeta"), textChMeta:$("textChMeta"),
      mapAudioIdx:$("mapAudioIdx"), mapTextIdx:$("mapTextIdx"), applyMap:$("applyMap"), mapInfo:$("mapInfo"),
      startChapterMode:$("startChapterMode"), transcribeThisChapter:$("transcribeThisChapter"), exportWav:$("exportWav"),
      sliceReplaceWav:$("sliceReplaceWav"),
      openDrawerDesktop:$("openDrawerDesktop"),
      player:$("player")
    };

    function isMobileUA(){
      const ua=navigator.userAgent||'';
      return /Mobi|Android|iPhone|iPad|iPod/i.test(ua)
          || (window.matchMedia && matchMedia('(pointer:coarse)').matches)
          || window.innerWidth<=768;
    }
    let IS_MOBILE=isMobileUA();
    function activePlayer(){ return IS_MOBILE ? el.player : el.playerDesktop; }

    // model URLs
    const BASE = new URL('.', location.href);
    const MOBILE_MODEL_URL  = new URL('models/en-us-mobile.tar.gz', BASE).href;
    const DESKTOP_MODEL_URL = new URL('models/en-us-desktop.zip', BASE).href;
    const MODEL_URL = IS_MOBILE ? MOBILE_MODEL_URL : DESKTOP_MODEL_URL;

    // timing & state
    const HILITE_LEAD=.04,HILITE_LAG=.06,MIN_WORD=.08,CLICK_PAD=.04,CLICK_MIN=.3,GAP_PAD=.01;
    let ADAPTIVE_ON=false,driftBias=0; const DRIFT_ALPHA=.12,DRIFT_CLAMP=.25;
    let AUDIO_FILE=null,MODEL=null,RECOG=null,LOG=[];
    let MODEL_WATCH={active:false,start:0,lastBeat:0,timer:null,canceled:false};
    let LAST_WORDS=[],PLAY_WORDS=[],HWIN=[],REF_TEXT='',TOKENS=[],MOB_TOKENS=[],CUR_HI=-1,__playTimer=null,ALIGNED_ONCE=false;
    let CURRENT_RATE=1.00;

    // decode cache + chapters
    let DECODE_CACHE=null; // {f32,sr,durationSec,file}
    let AUDIO_CH=[];       // [{title,start,end,index}]
    let TEXT_CH=[];        // [{title, idx, text}]
    let MAP_OFFSET=0;
    let CHAPTER_MODE=false;
    let CURRENT_AUDIO_CH_INDEX=0;
    let PREFETCHING=false;

    const NL='\n',ts=()=>new Date().toLocaleTimeString();
    function safe(o){try{if(o==null)return'';if(typeof o==='string')return o;return JSON.stringify(o,(k,v)=>typeof v==='bigint'?String(v):v)}catch{return'[unserializable]'}}

    function addLog(l,m,meta){
      const line=`[${ts()}] ${l.toUpperCase()}: ${m}${meta?` — ${safe(meta)}`:''}`;LOG.push(line);
      if(el.log){const d=document.createElement('div');d.textContent=line;d.className=l==='error'?'bad':l==='warn'?'warn':'ok';el.log.append(d);el.log.scrollTop=el.log.scrollHeight;}
      // Mirror to mobile drawer log
      const mob=document.getElementById('mLog');
      if(mob){const d2=document.createElement('div');d2.textContent=line;d2.className=l==='error'?'bad':l==='warn'?'warn':'ok';mob.append(d2);mob.scrollTop=mob.scrollHeight;while(mob.childElementCount>200) mob.firstChild.remove();}
      console[l==='error'?'error':l==='warn'?'warn':'log'](line,meta||'')
    }
    function setStatus(s){ if(el.status) el.status.innerHTML=`<small>${s}</small>`; addLog('info',s) }
    function setProg(v){ if(el.prog) el.prog.value=v }

    /* Drawer */
    function setDrawer(open){
      if(open){ el.drawer.classList.add('open'); el.overlay.hidden=false; el.drawer.setAttribute('aria-hidden','false'); }
      else { el.drawer.classList.remove('open'); el.overlay.hidden=true; el.drawer.setAttribute('aria-hidden','true'); }
    }
    el.mMenu?.addEventListener('click',()=>setDrawer(true));
    el.openDrawerDesktop?.addEventListener('click',()=>setDrawer(true));
    el.closeDrawer?.addEventListener('click',()=>setDrawer(false));
    el.overlay?.addEventListener('click',()=>setDrawer(false));

    (function moveControlsToDrawer(){
      if(!IS_MOBILE) return;
      const filesHost=el.secFiles, actionsHost=el.secActions, settingsHost=el.secSettings;
      el.audioFile?.closest('.field.audio') && filesHost?.appendChild(el.audioFile.closest('.field.audio'));
      el.refFile?.closest('.field.ref') && filesHost?.appendChild(el.refFile.closest('.field.ref'));
      el.go?.closest('.actions') && actionsHost?.appendChild(el.go.closest('.actions'));
      el.adaptiveToggle && settingsHost?.appendChild(el.adaptiveToggle.closest('label').parentElement);
      el.prog && settingsHost?.appendChild(el.prog.closest('.meter'));
    })();

    /* Speed popover */
    function setRate(v){
      const p=activePlayer();
      CURRENT_RATE=Math.max(0.5,Math.min(3.0,Number(v)||1));
      if(p) p.playbackRate=CURRENT_RATE;
      el.mSpeed.textContent=CURRENT_RATE.toFixed(2)+'×';
    }
    function openSpeedPopover(){
      const rect=el.mSpeed.getBoundingClientRect();
      const pop=el.speedPopover; pop.style.display='block';
      const w=pop.offsetWidth||220;
      const left=Math.min(rect.left, window.innerWidth - w - 8);
      pop.style.left=Math.round(Math.max(8,left))+'px';
      pop.style.top=Math.round(rect.bottom+8)+'px';
      el.speedInput.value=CURRENT_RATE.toFixed(2);
      const onDoc=(ev)=>{ if(!pop.contains(ev.target) && ev.target!==el.mSpeed){ closeSpeedPopover(); document.removeEventListener('mousedown',onDoc,true); } };
      document.addEventListener('mousedown',onDoc,true);
    }
    function closeSpeedPopover(){ el.speedPopover.style.display='none'; }
    el.mSpeed?.addEventListener('click',openSpeedPopover);
    el.speedApply?.addEventListener('click',()=>{ setRate(el.speedInput.value); closeSpeedPopover(); });
    document.querySelectorAll('.speedOpt').forEach(opt=>opt.addEventListener('click',()=>{ setRate(opt.dataset.sp); closeSpeedPopover(); }));

    /* Mobile times/seek */
    function fmtClock(sec){ if(!isFinite(sec)) return '0:00'; const s=Math.max(0,sec|0), m=(s/60|0), ss=(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; }
    function setMobileTimes(){
      if(!IS_MOBILE) return;
      const p=activePlayer(); if(!p || !isFinite(p.duration)) return;
      el.mElapsed.textContent=fmtClock(p.currentTime);
      el.mRemain.textContent='-'+fmtClock(Math.max(0,p.duration-p.currentTime));
      el.mTotal.textContent=fmtClock(p.duration);
      if(p.duration>0) el.mSeek.value = Math.round((p.currentTime / p.duration) * 1000) || 0;
    }
    el.mSeek?.addEventListener('input',()=>{ const p=activePlayer(); if(!p || !isFinite(p.duration)) return; p.currentTime = (+el.mSeek.value/1000)*p.duration; });

    /* Model load watchdog */
    function modelWatchStart(){MODEL_WATCH.active=true;MODEL_WATCH.canceled=false;MODEL_WATCH.start=Date.now();MODEL_WATCH.lastBeat=Date.now();el.cancelModel&&(el.cancelModel.style.display='inline-flex');MODEL_WATCH.timer&&clearInterval(MODEL_WATCH.timer);MODEL_WATCH.timer=setInterval(()=>{const now=Date.now(),sinceBeat=(now-MODEL_WATCH.lastBeat)/1e3,sinceStart=(now-MODEL_WATCH.start)/1e3;sinceBeat>45&&addLog('warn','Model load appears stalled',{idle_secs:sinceBeat});sinceStart>120&&addLog('warn','Model load unusually long',{elapsed_secs:sinceStart})},5e3)}
    function modelWatchBeat(msg){MODEL_WATCH.lastBeat=Date.now();msg&&addLog('info','model: '+msg)}
    function modelWatchEnd(){MODEL_WATCH.active=false;MODEL_WATCH.timer&&(clearInterval(MODEL_WATCH.timer),MODEL_WATCH.timer=null);el.cancelModel&&(el.cancelModel.style.display='none')}
    function modelCancel(){MODEL_WATCH.canceled=true;addLog('warn','Model load cancel requested')}
    el.cancelModel && (el.cancelModel.onclick=()=>modelCancel());

    /* Highlight + playback */
    function normalizeForPlayback(words){
      const out=words.map(w=>({word:w.word,start:+w.start,end:+w.end,conf:+(w.conf??1)})).filter(w=>Number.isFinite(w.start)&&Number.isFinite(w.end));
      if(!out.length) return out;
      for(let i=0;i<out.length;i++){
        const w=out[i],nextStart=i<out.length-1?out[i+1].start:w.end;
        w.end<w.start&&(w.end=w.start);
        w.end=Math.max(w.start+MIN_WORD,w.end);
        if(i<out.length-1){w.end=Math.min(w.end,nextStart-GAP_PAD);if(w.end<=w.start)w.end=Math.min(nextStart-GAP_PAD,w.start+MIN_WORD)}
      }
      for(let i=1;i<out.length;i++) if(out[i].start<out[i-1].end+GAP_PAD) out[i].start=Math.min(out[i].start,out[i-1].end+GAP_PAD);
      return out
    }
    function buildHighlightWindows(){HWIN=[];const n=PLAY_WORDS.length;if(!n)return;const C=PLAY_WORDS.map(w=>(w.start+w.end)/2);for(let i=0;i<n;i++){let L=i? (C[i-1]+C[i])/2 : (PLAY_WORDS[i].start-HILITE_LEAD),R=i===n-1? (PLAY_WORDS[i].end+HILITE_LAG):(C[i]+C[i+1])/2;i&&(L=Math.max(L,HWIN[i-1].end+1e-4));R<=L&&(R=L+1e-3);HWIN[i]={start:L,end:R}}}
    function playSegment(start,end){
      const p=activePlayer(); if(!p) return;
      try{
        const s=Math.max(0,(+start||0)-CLICK_PAD);
        let e=Math.max(s+CLICK_MIN,+end||s+CLICK_MIN);
        const dur=(p.duration&&isFinite(p.duration))?p.duration:null; dur!=null&&(e=Math.min(e,dur));
        try{!p.paused&&p.pause()}catch{}
        __playTimer&&(clearTimeout(__playTimer),__playTimer=null);
        p.currentTime=s; const pr=p.play(); pr&&pr.catch(()=>{});
        const playDur=Math.min(e-s,60); __playTimer=setTimeout(()=>{try{p.pause()}catch{}},playDur*1e3);
      }catch{}
    }
    function currentTimeAdj(){const p=activePlayer(); return p.currentTime+(ADAPTIVE_ON?driftBias:0)}
    function findWordIndexAt(t){if(!HWIN.length)return-1;let lo=0,hi=HWIN.length-1;for(;lo<=hi;){const mid=lo+hi>>1,w=HWIN[mid];if(t<w.start)hi=mid-1;else if(t>w.end)lo=mid+1;else return mid}return-1}
    function lerp(a,b,t){return a+(b-a)*t}
    function centerMobileToken(idx, progress01){
      if(!IS_MOBILE || idx<0 || !MOB_TOKENS[idx]) return;
      const cont=el.mText, tok=MOB_TOKENS[idx];
      const desired = Math.max(0, tok.offsetTop - (cont.clientHeight/2 - tok.clientHeight/2));
      cont.scrollTop = lerp(cont.scrollTop, desired, Math.min(0.35, 0.15 + progress01*0.5));
    }
    function setHighlight(i){
      if(i===CUR_HI) return;
      if(CUR_HI>=0){
        TOKENS[CUR_HI] && TOKENS[CUR_HI].classList.remove('playing');
        MOB_TOKENS[CUR_HI] && MOB_TOKENS[CUR_HI].classList.remove('playing');
      }
      CUR_HI=i;
      if(CUR_HI>=0){
        TOKENS[CUR_HI] && TOKENS[CUR_HI].classList.add('playing');
        MOB_TOKENS[CUR_HI] && MOB_TOKENS[CUR_HI].classList.add('playing');
        if(TOKENS[CUR_HI] && el.text){
          const t=TOKENS[CUR_HI], r=t.getBoundingClientRect(), host=el.text.getBoundingClientRect();
          (r.top<host.top+8||r.bottom>host.bottom-8)&&t.scrollIntoView({block:'center',inline:'nearest',behavior:'smooth'})
        }
      }
    }
    function adaptiveUpdate(idx){
      const p=activePlayer();
      if(!ADAPTIVE_ON||idx<0) return;
      const w=PLAY_WORDS[idx], mid=(w.start+w.end)/2, err=mid-p.currentTime;
      const next=driftBias*(1-DRIFT_ALPHA)+err*DRIFT_ALPHA; driftBias=Math.max(-DRIFT_CLAMP,Math.min(DRIFT_CLAMP,next))
    }
    function updateHighlightFromPlayer(){
      const p=activePlayer();
      if(IS_MOBILE) setMobileTimes();
      if(!PLAY_WORDS.length){setHighlight(-1);return}
      const t=currentTimeAdj(), idx=findWordIndexAt(t); setHighlight(idx); adaptiveUpdate(idx);
      if(IS_MOBILE && idx>=0){
        const w=PLAY_WORDS[idx];
        const prog=(t - w.start) / Math.max(1e-6,(w.end - w.start));
        centerMobileToken(idx, Math.max(0,Math.min(1,prog)));
      }

      // Prefetch next chapter at 80%
      if (CHAPTER_MODE && AUDIO_CH.length) {
        const ch=AUDIO_CH[CURRENT_AUDIO_CH_INDEX]; if(!ch) return;
        const chDur=(ch.end-ch.start);
        if(!PREFETCHING && chDur>1 && (p.currentTime - ch.start) > 0.8*chDur ){
          const nextIdx=CURRENT_AUDIO_CH_INDEX+1;
          if(nextIdx<AUDIO_CH.length) {
            PREFETCHING=true;
            const nextTextIdx = nextIdx + MAP_OFFSET;
            const refTxt = TEXT_CH[nextTextIdx]?.text || '';
            runChapter(nextIdx, false, refTxt).finally(()=>{PREFETCHING=false});
          }
        }
      }
    }
    ['timeupdate','seeked','ratechange','seeking'].forEach(ev=>{
      el.player?.addEventListener(ev,updateHighlightFromPlayer);
      el.playerDesktop?.addEventListener(ev,updateHighlightFromPlayer);
    });
    let __raf=null;function startHiLoop(){if(__raf)return;const step=()=>{updateHighlightFromPlayer();__raf=requestAnimationFrame(step)};__raf=requestAnimationFrame(step)}
    function stopHiLoop(){__raf&&(cancelAnimationFrame(__raf),__raf=null)}
    el.player?.addEventListener('play',startHiLoop);
    el.player?.addEventListener('pause',stopHiLoop);
    el.player?.addEventListener('ended',()=>{stopHiLoop();setHighlight(-1)});
    el.playerDesktop?.addEventListener('play',startHiLoop);
    el.playerDesktop?.addEventListener('pause',stopHiLoop);
    el.playerDesktop?.addEventListener('ended',()=>{stopHiLoop();setHighlight(-1)});
    el.adaptiveToggle?.addEventListener('change',()=>{ADAPTIVE_ON=!!el.adaptiveToggle.checked;ADAPTIVE_ON||(driftBias=0);addLog('info','Adaptive '+(ADAPTIVE_ON?'on':'off'),{bias:driftBias})});

    /* Files */
    function attachAudioFile(file){
      if(!file) return;
      AUDIO_FILE=file;
      addLog('info','Audio selected',{name:file.name,size:file.size,type:file.type});
      try{
        const url=URL.createObjectURL(file);
        const p=activePlayer(); if (p){ p.src=url; p.load(); }
        if(IS_MOBILE){ el.mTitle.textContent=file.name || 'Audio' } else { el.audioTitle && (el.audioTitle.textContent=file.name || 'Audio') }
      }catch(e){ addLog('warn','Attach audio failed',String(e)) }
      REF_TEXT=''; el.refFile && (el.refFile.value=''); ALIGNED_ONCE=false; refreshAlignButton(); addLog('info','Reference cleared for new audio');

      AUDIO_CH=[]; CURRENT_AUDIO_CH_INDEX=0; populateAudioChapterUI();
      DECODE_CACHE=null;

      if (file.name.toLowerCase().endsWith('.m4b')) {
        parseM4BChapters(file).catch(e=>addLog('warn','m4b chapters fail',String(e)));
      }
    }
    el.audioFile && (el.audioFile.onchange=()=>attachAudioFile(el.audioFile.files?.[0]||null));

    el.refFile && (el.refFile.onchange=async()=>{
      const f=el.refFile.files?.[0]; if(!f){REF_TEXT='';ALIGNED_ONCE=false;refreshAlignButton();TEXT_CH=[];populateTextChapterUI();return}
      const name=f.name.toLowerCase();
      if(name.endsWith('.epub')){
        TEXT_CH=[]; populateTextChapterUI();
        try{ await parseEpubChapters(f); addLog('info','EPUB chapters', {count:TEXT_CH.length}); }
        catch(e){ addLog('error','EPUB parse failed', String(e)); }
        ALIGNED_ONCE=false; refreshAlignButton();
      }else{
        try{ const txt=await f.text(); REF_TEXT=txt; addLog('info','Reference text loaded',{chars:txt.length}); TEXT_CH=[{title:f.name,text:txt,idx:0}]; populateTextChapterUI(); }
        catch(e){ addLog('error','Read ref text failed',String(e)); REF_TEXT=''; TEXT_CH=[]; populateTextChapterUI(); }
        ALIGNED_ONCE=false; refreshAlignButton();
      }
    });

    el.copy && (el.copy.onclick=async()=>{await navigator.clipboard.writeText(LOG.join(NL));addLog('info','Log copied')});
    el.save && (el.save.onclick=()=>{const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([LOG.join(NL)],{type:'text/plain'}));a.download='offline_vosk_log.txt';a.click()});

    /* Vosk */
    if (window.Vosk && Vosk.setWasmPrefix) Vosk.setWasmPrefix("https://unpkg.com/vosk-browser@0.0.8/dist/");
    if (window.Vosk && Vosk.setLogLevel) { Vosk.setLogLevel(0); }

    async function headCheck(url){ try { const r = await fetch(url, { method:"HEAD" }); return { ok:r.ok, status:r.status, len:r.headers.get("content-length"), type:r.headers.get("content-type") }; } catch(e){ return { ok:false, error:String(e) }; }
    }
    function withTimeout(promise, ms, label="operation"){ let t; const timer=new Promise((_,rej)=>t=setTimeout(()=>rej(new Error(label+" timed out")),ms)); return Promise.race([promise.finally(()=>clearTimeout(t)), timer]); }
    function destroyRecognizer(){if(RECOG){try{RECOG.remove&&RECOG.remove()}catch{}RECOG=null}}

    async function ensureModel(){
      if(typeof Vosk==='undefined'){addLog('error','Vosk not loaded');alert('Vosk failed to load');return null}
      if(MODEL) return MODEL;
      const chosen=MODEL_URL;
      setStatus(`Loading Vosk model… (${IS_MOBILE?'mobile':'desktop'})`);
      setProg(1); modelWatchStart();

      const head = await headCheck(chosen);
      if(!head.ok){
        modelWatchEnd();
        addLog('error','Model URL not reachable',{url:chosen,...head});
        alert(`Model URL not reachable (${head.status || head.error}). Check the /models path & CORS.`);
        return null;
      }
      addLog('info','Model URL preflight ok',{url:chosen,bytes:head.len,type:head.type});

      try{
        modelWatchBeat('createModel via URL');
        const t0=performance.now();
        MODEL = await withTimeout(Vosk.createModel(chosen), IS_MOBILE?150000:90000, "createModel");
        addLog('info','Model created via URL',{ms:Math.round(performance.now()-t0),url:chosen});
      }catch(e){
        modelWatchEnd();
        addLog('error','createModel(URL) failed',String(e));
        const fallback = chosen.replace(/\.(zip|tar\.gz|tgz)$/i,'/model.json');
        if(fallback!==chosen){
          const probe=await headCheck(fallback);
          if(probe.ok){
            try{
              addLog('info','Trying pre-extracted model.json',{url:fallback});
              MODEL = await withTimeout(Vosk.createModel(fallback),60000,"createModel(model.json)");
            }catch(e2){ addLog('error','Fallback model.json failed',String(e2)); }
          }
        }
      } finally { modelWatchEnd(); }

      if(MODEL_WATCH.canceled){setStatus('Model load canceled');return null}
      if(!MODEL){setStatus('Model load failed');alert('Model load failed — see Log for details.');return null}
      return MODEL;
    }

    /* Decode cache */
    async function ensureDecode(){
      if(DECODE_CACHE && AUDIO_FILE===DECODE_CACHE.file) return DECODE_CACHE;
      if(!AUDIO_FILE) throw new Error('No audio file');
      const {f32,sr}=await decodeToMonoF32(AUDIO_FILE);
      DECODE_CACHE={f32,sr,durationSec:f32.length/sr,file:AUDIO_FILE};
      return DECODE_CACHE;
    }

    async function decodeToMonoF32(file){
      const buf=await file.arrayBuffer(),AC=window.AudioContext||window.webkitAudioContext,cx=new AC(),ab=await cx.decodeAudioData(buf),chs=ab.numberOfChannels,sr=ab.sampleRate,frames=ab.length;addLog('info','Audio decoded',{sr,chs,frames,secs:ab.duration.toFixed(3)});
      const mono=new Float32Array(frames);
      for(let c=0;c<chs;c++){const data=ab.getChannelData(c);for(let i=0;i<frames;i++)mono[i]+=data[i]/chs}
      const target=16000,res=resampleF32(mono,sr,target);addLog('info','Resampled',{from:sr,to:target,samples:res.length});await cx.close();return{f32:res,sr:target}
    }
    function resampleF32(input,src,dst){if(src===dst)return input;const ratio=dst/src,outLen=Math.round(input.length*ratio),out=new Float32Array(outLen);for(let i=0;i<outLen;i++){const x=i/ratio,xi=Math.floor(x),t=x-xi,a=input[xi]||0,b=input[xi+1]||0;out[i]=a+(b-a)*t}return out}
    function floatToInt16(f32){const i16=new Int16Array(f32.length);for(let i=0;i<f32.length;i++){let s=Math.max(-1,Math.min(1,f32[i]));i16[i]=s<0?Math.round(s*32768):Math.round(s*32767)}return i16}

    /* RUN */
    function refreshAlignButton(){
      if(!el.align) return;
      if(!REF_TEXT && !(TEXT_CH && TEXT_CH.length)){el.align.disabled=true;el.align.textContent='Align & Correct (current chapter)';el.align.title='Load a TXT or EPUB to enable'}
      else{el.align.disabled=false;el.align.textContent=ALIGNED_ONCE?'Re-Align (current chapter)':'Align & Correct (current chapter)';el.align.title=ALIGNED_ONCE?'Run alignment again':'Align transcript to reference'}
    }

    async function runChapter(audioChapterIndex, makeActive=true, overrideRef=''){
      const model=await ensureModel(); if(!model) return;
      const cache=await ensureDecode();

      const idx = Number.isFinite(audioChapterIndex) ? audioChapterIndex : 0;
      const ch=AUDIO_CH[idx] || {start:0,end:cache.durationSec,title:'Whole file',index:1};
      const start=ch.start, end=Math.min(ch.end, cache.durationSec);
      addLog('info','Transcribing chapter', {idx,title:ch.title,start,end});

      const sr=cache.sr, f32=cache.f32.subarray( Math.floor(start*sr), Math.floor(end*sr) );
      const i16=floatToInt16(f32);
      setStatus(`Transcribing… ${ch.title}`); setProg(12);

      destroyRecognizer();
      try{RECOG=model.KaldiRecognizer?new model.KaldiRecognizer(sr):new model.Recognizer(sr)}catch(e){addLog('error','Recognizer create failed',String(e));alert('Recognizer create failed — see log');return}
      RECOG.setWords&&RECOG.setWords(true);
      const useFloat=!!RECOG.acceptWaveformFloat;

      const words=[];
      const pullAll=()=>{
        let pulled=0;
        if(RECOG.result){
          for(;;){
            let r=RECOG.result(); if(typeof r==='string'){ try{ r=JSON.parse(r) }catch{} }
            const arr=r?.result||[]; if(arr && arr.length){ arr.forEach(x=>words.push(x)); pulled+=arr.length; } else break;
          }
        }
        if(RECOG.finalResult){
          let fr=RECOG.finalResult(); if(typeof fr==='string'){ try{ fr=JSON.parse(fr) }catch{} }
          const arr=fr?.result||[]; if(arr && arr.length){ arr.forEach(x=>words.push(x)); pulled+=arr.length; }
        }
        return pulled;
      };

      const CH=Math.max(1, sr*.5|0); let off=0,n=0;
      while(off<(useFloat?f32.length:i16.length)){
        const slice=useFloat?f32.subarray(off,Math.min(f32.length,off+CH)):i16.subarray(off,Math.min(i16.length,off+CH));
        off+=CH; n++;
        try{
          if(useFloat){ RECOG.acceptWaveformFloat(slice,sr); }
          else{ RECOG.acceptWaveform.length===2 ? RECOG.acceptWaveform(slice,sr) : RECOG.acceptWaveform(slice); }
        }catch(e){ addLog('error','acceptWaveform failed',String(e)); break; }
        if(n%8===0){ const denom=useFloat?f32.length:i16.length; setProg(12+Math.min(80,Math.round(off/denom*80))); }
        await new Promise(r=>setTimeout(r,0));
      }
      try{ const tail=sr*1|0; if(useFloat){RECOG.acceptWaveformFloat(new Float32Array(tail),sr)}else{RECOG.acceptWaveform.length===2?RECOG.acceptWaveform(new Int16Array(tail),sr):RECOG.acceptWaveform(new Int16Array(tail))} }catch{}

      for(let k=0;k<3;k++){ await new Promise(r=>setTimeout(r,80)); pullAll(); }

      // shift to absolute file time
      const shifted=words.filter(w=>Number.isFinite(w.start)&&Number.isFinite(w.end))
        .map(w=>({word:String(w.word||'').trim(), start:start + +w.start, end:start + +w.end, conf:+(w.conf??1)}));

      const refTxt = overrideRef || (TEXT_CH[(idx + MAP_OFFSET)]?.text || REF_TEXT || '');
      LAST_WORDS = shifted;
      if (refTxt && refTxt.trim()){
        try{
          const corrected = alignAndCorrect(LAST_WORDS, refTxt);
          addLog('info','Align & Correct (chapter)',{orig:LAST_WORDS.length,corrected:corrected.length});
          LAST_WORDS = corrected; ALIGNED_ONCE=true; refreshAlignButton();
        }catch(e){ addLog('warn','Chapter align failed', String(e)); }
      }

      PLAY_WORDS=normalizeForPlayback(LAST_WORDS); buildHighlightWindows(); render(PLAY_WORDS);
      setProg(100);
      setStatus(`<span class="accent">Done</span> ${LAST_WORDS.length} words — ${ch.title}`);
      updateHighlightFromPlayer();

      if(makeActive){
        CURRENT_AUDIO_CH_INDEX=idx;
        const p=activePlayer(); try{ p.pause(); }catch{} p.currentTime = ch.start; p.playbackRate = CURRENT_RATE;
      }
    }

    async function run(){
      LOG.length=0; el.log && (el.log.textContent='(log starts here)');
      const mob=document.getElementById('mLog'); if(mob) mob.textContent='';
      el.text && (el.text.textContent='(no transcript yet)'); el.tb && (el.tb.innerHTML='');
      el.mText && (el.mText.textContent='(no transcript yet)'); setProg(0);
      if(!AUDIO_FILE){alert('Choose an audio file (hamburger ▶ Files).');setDrawer(true);return}
      const idx = getSelectedAudioIndex();
      const textIdx = idx + MAP_OFFSET;
      const refTxt = TEXT_CH[textIdx]?.text || '';
      return runChapter(idx, true, refTxt);
    }

    /* Align helpers */
    function normalizeToken(s){return String(s).toLowerCase().replace(/[^a-z]+/g,'')}
    function tokenizeReference(text){return text.split(/\s+/).filter(Boolean).map(tok=>{const norm=normalizeToken(tok);return norm?{raw:tok,norm}:null}).filter(Boolean)}
    function levenshtein(a,b){const m=a.length,n=b.length,dp=new Array(n+1);for(let j=0;j<=n;j++)dp[j]=j;for(let i=1;i<=m;i++){let prev=dp[0];dp[0]=i;for(let j=1;j<=n;j++){const ins=dp[j]+1,del=dp[j-1]+1,sub=prev+(a[i-1]===b[j-1]?0:1);prev=dp[j];dp[j]=Math.min(ins,del,sub)}}return dp[n]}
    function sim(a,b){if(!a.length&&!b.length)return 1;const d=levenshtein(a,b);return 1-d/Math.max(1,Math.max(a.length,b.length))}
    function joinNorm(arr){return arr.map(x=>normalizeToken(typeof x==='string'?x:x.word||x.raw||'')).join('')}
    function alignAndCorrect(hypWords,refText){
      const ref=tokenizeReference(refText),hyp=hypWords.map(w=>({raw:w.word,norm:normalizeToken(w.word),start:w.start,end:w.end,conf:w.conf}));
      const n=hyp.length,m=ref.length,H=3,R=3,BIG=1e9,PEN_GROUP=.005,PEN_SIZE=.01;
      function score(i1,i2,j1,j2){const hg=hyp.slice(i1,i2),rg=ref.slice(j1,j2),hj=joinNorm(hg),rj=rg.map(x=>x.norm).join(''),base=1-sim(hj,rj),pen=PEN_GROUP*(hg.length+rg.length-2)+PEN_SIZE*Math.abs(hg.length-rg.length);return base+pen}
      const dp=Array.from({length:n+1},()=>Array(m+1).fill(BIG)),back=Array.from({length:n+1},()=>Array(m+1).fill(null));dp[0][0]=0;
      for(let i=0;i<=n;i++)for(let j=0;j<=m;j++){const cur=dp[i][j];if(cur===BIG)continue;for(let hi=1;hi<=H&&i+hi<=n;hi++)for(let rj=1;rj<=R&&j+rj<=m;rj++){const c=score(i,i+hi,j,j+rj),nc=cur+c;if(nc<dp[i+hi][j+rj]){dp[i+hi][j+rj]=nc;back[i+hi][j+rj]={i0:i,j0:j,hi,rj}}}}
      const groups=[];if(back[n][m]==null){let i=0,j=0;while(i<n&&j<m){groups.push({i0:i,j0:j,hi:1,rj:1});i++;j++}}else{let i=n,j=m;while(i>0&&j>0){const b=back[i][j];groups.push(b);i=b.i0;j=b.j0}groups.reverse()}
      const out=[];let prevEnd=null;
      for(const g of groups){
        const hypG=hyp.slice(g.i0,g.i0+g.hi),refG=ref.slice(g.j0,g.j0+g.rj);
        let gStart=Math.min(...hypG.map(t=>t.start)),gEnd=Math.max(...hypG.map(t=>t.end));
        if(prevEnd!=null&&gStart<prevEnd){gStart=prevEnd;gEnd<gStart&&(gEnd=gStart)}
        if(g.rj===1){out.push({word:refG[0].raw,start:gStart,end:gEnd,conf:1})}
        else if(g.hi===1){const total=refG.reduce((a,b)=>a+b.norm.length,0)||g.rj;let cur=gStart;for(let idx=0;idx<refG.length;idx++){const rr=refG[idx],frac=(rr.norm.length||1)/total;let next=idx===refG.length-1?gEnd:Math.min(gEnd,cur+frac*(gEnd-gStart));out.push({word:rr.raw,start:cur,end:next,conf:1});cur=next}}
        else{const step=(gEnd-gStart)/g.rj||0;for(let k=0;k<g.rj;k++){const a=gStart+k*step,b=k===g.rj-1?gEnd:gStart+(k+1)*step;out.push({word:refG[k].raw,start:a,end:b,conf:1})}}
        prevEnd=out[out.length-1].end
      }
      const produced=groups.reduce((s,g)=>s+g.rj,0);
      if(produced<ref.length){let cur=prevEnd??0;for(let j=produced;j<ref.length;j++){const w=ref[j];out.push({word:w.raw,start:cur,end:cur+.25,conf:.5});cur+=.25}}
      return out
    }

    function fmt(t){if(!isFinite(t))return'';const s=t|0,ms=Math.round((t-(t|0))*1e3).toString().padStart(3,'0'),m=(s/60|0).toString().padStart(2,'0'),ss=(s%60).toString().padStart(2,'0');return`${m}:${ss}.${ms}`}
    function escapeHtml(s){return String(s).replace(/[&<>"]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]))}

    function render(words){
      // desktop
      if(el.text){ const cont=el.text,tb=el.tb; cont.innerHTML=''; tb && (tb.innerHTML=''); TOKENS=[]; CUR_HI=-1;
        if(!words.length){cont.textContent='(empty)'} else {
          const frag=document.createDocumentFragment();
          words.forEach((w,i)=>{i&&frag.append(' ');const sp=document.createElement('span');sp.className='token';sp.dataset.idx=String(i);sp.textContent=w.word;sp.title=`${fmt(w.start)} → ${fmt(w.end)} (conf ${(w.conf??0).toFixed(2)}) — click to play`;frag.append(sp)});
          cont.append(frag); TOKENS=Array.from(cont.querySelectorAll('.token'));
          if(tb){const rows=document.createDocumentFragment();
            words.forEach((w,i)=>{const tr=document.createElement('tr');tr.innerHTML=`<td class="play"><button class="playbtn" data-idx="${i}" title="Play word">▶</button></td><td>${i+1}</td><td>${escapeHtml(w.word)}</td><td class="mobile-hide">${fmt(w.start)}</td><td class="mobile-hide">${fmt(w.end)}</td><td class="mobile-hide">${(w.conf??0).toFixed(2)}</td>`;rows.append(tr)});
            tb.append(rows);
          }
        }
      }
      // mobile viewport
      if(el.mText){
        const m=el.mText; m.innerHTML=''; MOB_TOKENS=[]; CUR_HI=-1;
        if(!words.length){m.textContent='(empty)'} else {
          const frag2=document.createDocumentFragment();
          words.forEach((w,i)=>{i&&frag2.append(' ');const sp=document.createElement('span');sp.className='token';sp.dataset.idx=String(i);sp.textContent=w.word;frag2.append(sp)});
          m.append(frag2); MOB_TOKENS=Array.from(m.querySelectorAll('.token'));
        }
        if (AUDIO_CH.length) {
          const ch=AUDIO_CH[CURRENT_AUDIO_CH_INDEX]||AUDIO_CH[0];
          el.mChapterIdx.textContent=String(CURRENT_AUDIO_CH_INDEX+1).padStart(3,'0');
          el.mChapterClock.textContent=fmt(ch.start).slice(0,5);
          el.mChapterLen.textContent=fmt(ch.end-ch.start).slice(0,5);
        } else {
          el.mChapterIdx.textContent='—'; el.mChapterClock.textContent='—'; el.mChapterLen.textContent='—';
        }
      }
      addLog('info','Rendered',{words:words.length});
    }

    // click-to-play
    el.text?.addEventListener('click',ev=>{const t=ev.target.closest('.token');if(!t)return;const idx=+t.dataset.idx,w=PLAY_WORDS[idx];if(!w)return;playSegment(w.start,w.end)});
    el.tb?.addEventListener('click',ev=>{const b=ev.target.closest('.playbtn');if(!b)return;const idx=+b.dataset.idx,w=PLAY_WORDS[idx];if(!w)return;playSegment(w.start,w.end)});
    el.mText?.addEventListener('click',ev=>{const t=ev.target.closest('.token');if(!t)return;const idx=+t.dataset.idx,w=PLAY_WORDS[idx];if(!w)return;playSegment(w.start,w.end)});

    // --- FFmpeg (UMD) dynamic loader -----------------------------------------
    async function loadScript(src, timeoutMs = 45000){
      return new Promise((resolve, reject)=>{
        const s = document.createElement('script');
        let done = false;
        const timer = setTimeout(()=>{ if(!done){ done=true; s.remove(); reject(new Error('timeout')); } }, timeoutMs);
        s.src = src; s.async = true;
        s.onload = ()=>{ if(!done){ done=true; clearTimeout(timer); resolve(); } };
        s.onerror = ()=>{ if(!done){ done=true; clearTimeout(timer); reject(new Error('network error')); } };
        document.head.appendChild(s);
      });
    }
    async function headOk(url){
      try{ const r = await fetch(url, { method:'HEAD' }); return r.ok; }catch{ return false; }
    }
  
    async function loadFFmpegIfNeeded(){
      if (window.FFmpeg) return 'already';
  
      const LOCAL_BASE = new URL('ffmpeg/', location.href).href;
      const CANDIDATES = [
        // Prefer self-hosted UMD:
        new URL('ffmpeg.min.js', LOCAL_BASE).href,
  
        // CDN fallbacks — UMD (NOT ESM)
        'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.min.js',
        'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.min.js',
      ];
  
      if (location.protocol === 'file:'){
        addLog('warn','Opened via file:// — WebAssembly cannot load ffmpeg-core.wasm from file://. Serve over http:// instead.');
      }
  
      for (const url of CANDIDATES){
        try{
          if (url.startsWith(LOCAL_BASE)){
            const ok = await headOk(url);
            if (!ok){ addLog('warn','Local ffmpeg.min.js not found',{url}); continue; }
          }
          addLog('info','Loading FFmpeg script…',{url});
          await loadScript(url, 60000);
          if (window.FFmpeg){ addLog('info','FFmpeg script OK',{url}); return url; }
        }catch(err){
          addLog('warn','FFmpeg script failed',{url, err:String(err)});
        }
      }
      throw new Error('FFmpeg UMD script could not be loaded from any source');
    }
  
    let __ffmpeg = null, __ffmpegLoading = null;
  
    async function ensureFFmpeg(){
      if (__ffmpeg) return __ffmpeg;
      if (__ffmpegLoading) return __ffmpegLoading;
  
      if (!window.FFmpeg){
        await loadFFmpegIfNeeded().catch(e=>{
          addLog('error','FFmpeg script not available — cannot slice/export WAV from .m4b', String(e));
          throw e;
        });
      }
      const { createFFmpeg } = FFmpeg;
  
      // Use UMD single-thread core (3 files: js, wasm; NO worker)
      const LOCAL_BASE = new URL('ffmpeg/', location.href).href;
      const CORE_CANDIDATES = [
        new URL('ffmpeg-core.js', LOCAL_BASE).href,                                         // local UMD core
        'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js',       // CDN UMD core
        'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js',                  // mirror
      ];
  
      let corePath = CORE_CANDIDATES[0];
      let found = false;
      for (const c of CORE_CANDIDATES){
        if (c.startsWith(LOCAL_BASE)){
          if (await headOk(c)){ corePath = c; found = true; break; }
        } else {
          if (location.protocol !== 'file:' && await headOk(c)){ corePath = c; found = true; break; }
        }
      }
      if (!found){
        addLog('error','ffmpeg-core.js not found locally or reachable via CDN (UMD).');
      }
  
      __ffmpegLoading = (async()=>{
        addLog('info','Loading ffmpeg.wasm…',{ corePath });
        const ff = createFFmpeg({ log:false, corePath });
        await ff.load();                              // will fetch ffmpeg-core.wasm from same folder
        addLog('info','ffmpeg.wasm ready');
        return ff;
      })();
  
      __ffmpeg = await __ffmpegLoading;
      return __ffmpeg;
    }
  
    async function probeFfmpegAvailabilityOnce(){
      const needsFfmpegBtns = [el.exportWav, el.sliceReplaceWav].filter(Boolean);
      try{
        const localCore = new URL('ffmpeg/ffmpeg-core.js', location.href).href;
        const ok = (await headOk(localCore)) ||
                   (location.protocol!=='file:' &&
                     (await headOk('https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js') ||
                      await headOk('https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js')));
        if (!ok){
          needsFfmpegBtns.forEach(b=>{ b.disabled = true; b.title = 'FFmpeg unavailable — see Log for setup steps.'; });
          addLog('warn','FFmpeg unavailable. “Export WAV” and “Slice → Use WAV” disabled.');
          addLog('info',
            'Self-host checklist:\n' +
            '1) Create folder "ffmpeg" next to this HTML.\n' +
            '2) Download UMD builds (v0.12.10) into ./ffmpeg :\n' +
            '   - ffmpeg.min.js (from @ffmpeg/ffmpeg)\n' +
            '   - ffmpeg-core.js and ffmpeg-core.wasm (from @ffmpeg/core)\n' +
            '3) Serve over HTTP (not file://). Example: python -m http.server 8000'
          );
        }else{
          addLog('info','FFmpeg seems reachable (local or CDN). Buttons enabled.');
        }
      }catch(e){
        addLog('warn','FFmpeg probe failed', String(e));
      }
    }
    
    // Slice [startSec, endSec] from an .m4b into a 16k mono WAV blob
    async function m4bSliceToWavUsingFFmpeg(file, startSec, endSec){
      const ff = await ensureFFmpeg();
      const inName  = 'in.m4b';
      const outName = 'out.wav';
      ff.FS('writeFile', inName, await FFmpeg.fetchFile(file));
      const ss = Math.max(0, startSec || 0);
      const useTo = Number.isFinite(endSec) && (endSec > ss + 0.02); // avoid -to 0 & zero-length
      const args = [
        '-ss', String(ss),
        ...(useTo ? ['-to', String(endSec)] : []),
        '-i', inName,
        '-ac', '1',
        '-ar', '16000',
        '-c:a', 'pcm_s16le',
        '-y', outName
      ];
      addLog('info','ffmpeg slice', { args: args.join(' ') });
      await ff.run(...args);
      const data = ff.FS('readFile', outName);
      try{ ff.FS('unlink', inName); ff.FS('unlink', outName); }catch{}
      return new Blob([data.buffer], { type: 'audio/wav' });
    }

    /* ===== Chapters UI helpers ===== */
    function getSelectedAudioIndex(){
      let idx = Number.isFinite(+el.audioChSel.value) ? (+el.audioChSel.value|0) : 0;
      if(!Number.isFinite(idx) || idx<0 || idx>=AUDIO_CH.length) idx=0;
      return idx;
    }

    function populateAudioChapterUI(){
      const sel=el.audioChSel; sel.innerHTML='';
      if(!AUDIO_CH.length){el.audioChMeta.textContent='(no audio chapters)'; return;}
      AUDIO_CH.forEach((c,i)=>{const o=document.createElement('option');o.value=i;o.textContent=`${(i+1).toString().padStart(3,'0')}  ${c.title}  (${fmt(c.start).slice(0,5)}–${fmt(c.end).slice(0,5)})`; sel.appendChild(o)});
      el.audioChMeta.textContent=`${AUDIO_CH.length} audio chapters`;
      sel.value = String(CURRENT_AUDIO_CH_INDEX);
      if(sel.selectedIndex===-1) sel.selectedIndex = 0;
      el.mapAudioIdx.value = String(getSelectedAudioIndex());
      updateMapInfo();
    }

    function populateTextChapterUI(){
      const sel=el.textChSel; sel.innerHTML='';
      if(!TEXT_CH.length){el.textChMeta.textContent='(no text chapters)'; return;}
      TEXT_CH.forEach((c,i)=>{const o=document.createElement('option');o.value=i;o.textContent=`${(i+1).toString().padStart(3,'0')}  ${c.title}`; sel.appendChild(o)});
      el.textChMeta.textContent=`${TEXT_CH.length} text chapters`;
      if(sel.selectedIndex===-1) sel.selectedIndex=0;
      el.mapTextIdx.value = String(sel.selectedIndex);
      updateMapInfo();
    }

    function updateMapInfo(){
      const a=+el.mapAudioIdx.value|0, t=+el.mapTextIdx.value|0;
      MAP_OFFSET = t - a;
      el.mapInfo.textContent=`Offset = textStart - audioStart = ${MAP_OFFSET}`;
    }
    el.applyMap?.addEventListener('click',updateMapInfo);
    el.startChapterMode?.addEventListener('click',()=>{
      if(!AUDIO_CH.length){ alert('No audio chapters loaded'); return; }
      CHAPTER_MODE=true;
      if(el.audioChSel.selectedIndex===-1) el.audioChSel.selectedIndex=0;
      CURRENT_AUDIO_CH_INDEX = getSelectedAudioIndex();
      const p=activePlayer();
      const ch=AUDIO_CH[CURRENT_AUDIO_CH_INDEX];
      try{ p.pause(); }catch{}
      p.currentTime=ch.start; p.playbackRate=CURRENT_RATE;
      const refTxt = TEXT_CH[CURRENT_AUDIO_CH_INDEX + MAP_OFFSET]?.text || '';
      runChapter(CURRENT_AUDIO_CH_INDEX,false,refTxt).catch(()=>{});
    });

    el.transcribeThisChapter?.addEventListener('click',()=>{
      if(!AUDIO_CH.length){ addLog('warn','No audio chapters to transcribe'); alert('Load an .m4b with chapters first.'); return; }
      if(el.audioChSel.selectedIndex===-1) el.audioChSel.selectedIndex=0;
      const idx = getSelectedAudioIndex();
      CURRENT_AUDIO_CH_INDEX=idx;
      const refTxt=TEXT_CH[idx + MAP_OFFSET]?.text || '';
      runChapter(idx,true,refTxt);
    });

    el.audioChSel?.addEventListener('change',()=>{ const idx=getSelectedAudioIndex(); el.mapAudioIdx.value=idx; CURRENT_AUDIO_CH_INDEX=idx; updateMapInfo(); });
    el.textChSel?.addEventListener('change',()=>{ const idx=+el.textChSel.value|0; el.mapTextIdx.value=idx; updateMapInfo(); });

    /* ===== Robust m4b chapter parsing (QuickTime text-track + Nero chpl) ===== */
    function readBoxes(dv, start, end){
      const boxes=[]; let off=start;
      while(off+8<=end){
        let size=dv.getUint32(off);
        const type=String.fromCharCode(dv.getUint8(off+4),dv.getUint8(off+5),dv.getUint8(off+6),dv.getUint8(off+7));
        let header=8;
        if(size===1){ const hi=dv.getUint32(off+8), lo=dv.getUint32(off+12); size=Number((BigInt(hi)<<32n)+BigInt(lo)); header=16; }
        else if(size===0){ size=end-off; }
        if(size<header || off+size>end) break;
        boxes.push({type,start:off,size,header,end:off+size,children:null});
        off+=size||8;
      }
      return boxes;
    }
    function parseTree(dv, start, end){
      const top=readBoxes(dv,start,end);
      const walk=(box)=>{
        const container=["moov","trak","mdia","minf","stbl","edts","udta","meta","ilst"].includes(box.type);
        if(box.type==="meta"){
          const payloadStart = box.start + box.header + 4;
          box.children = readBoxes(dv, payloadStart, box.end).map(b=>walk(b));
        }else if(container){
          box.children = readBoxes(dv, box.start+box.header, box.end).map(b=>walk(b));
        }else{ box.children=[]; }
        return box;
      };
      return top.map(walk);
    }
    function findPath(root, path){
      let cur=root, last=null;
      for(const p of path){ last=(cur||[]).find(b=>b.type===p); if(!last) return null; cur=last.children||[]; }
      return last;
    }
    function getDurationSeconds(dv, root){
      const mvhd=findPath(root,["moov","mvhd"]); if(!mvhd) return null;
      let off=mvhd.start+mvhd.header; const ver=dv.getUint8(off); off+=1; off+=3;
      if(ver===1){ off+=8; off+=8; const timescale=dv.getUint32(off); off+=4; const hi=dv.getUint32(off), lo=dv.getUint32(off+4); off+=8; const dur=Number((BigInt(hi)<<32n)+BigInt(lo)); return timescale?dur/timescale:null; }
      else { off+=4; off+=4; const timescale=dv.getUint32(off); off+=4; const dur=dv.getUint32(off); off+=4; return timescale?dur/timescale:null; }
    }
    function parseTextTrack(dv, root){
      const moov=root.find(b=>b.type==='moov'); if(!moov) return {entries:[],debug:"no moov"};
      const traks=moov.children.filter(b=>b.type==='trak');
      for(const trak of traks){
        const mdia=trak.children.find(b=>b.type==='mdia'); if(!mdia) continue;
        const hdlr=mdia.children.find(b=>b.type==='hdlr'); if(!hdlr) continue;
        const hOff=hdlr.start+hdlr.header;
        const handler=String.fromCharCode(dv.getUint8(hOff+8),dv.getUint8(hOff+9),dv.getUint8(hOff+10),dv.getUint8(hOff+11));
        if(!["text","sbtl","subt"].includes(handler)) continue;

        const mdhd=mdia.children.find(b=>b.type==='mdhd'); if(!mdhd) continue;
        let mOff=mdhd.start+mdhd.header; const ver=dv.getUint8(mOff); mOff+=1; mOff+=3;
        let timescale; if(ver===1){ mOff+=8; mOff+=8; timescale=dv.getUint32(mOff); } else { mOff+=4; mOff+=4; timescale=dv.getUint32(mOff); }

        const minf=mdia.children.find(b=>b.type==='minf'); if(!minf) continue;
        const stbl=minf.children.find(b=>b.type==='stbl'); if(!stbl) continue;

        const stts=stbl.children.find(b=>b.type==='stts'); if(!stts) continue;
        let tOff=stts.start+stts.header; tOff+=4; const n=dv.getUint32(tOff); tOff+=4;
        const dts=[]; let t=0;
        for(let i=0;i<n;i++){ const count=dv.getUint32(tOff); tOff+=4; const delta=dv.getUint32(tOff); tOff+=4; for(let j=0;j<count;j++){ dts.push(t); t+=delta; } }

        const stsz=stbl.children.find(b=>b.type==='stsz'); if(!stsz) continue;
        let zOff=stsz.start+stsz.header; zOff+=4; const sampleSize=dv.getUint32(zOff); zOff+=4; const sampleCount=dv.getUint32(zOff); zOff+=4;
        const sizes = sampleSize ? Array(sampleCount).fill(sampleSize) : Array.from({length:sampleCount},(_,i)=>dv.getUint32(zOff+i*4));

        const stsc=stbl.children.find(b=>b.type==='stsc'); if(!stsc) continue;
        let cOff=stsc.start+stsc.header; cOff+=4; const cCount=dv.getUint32(cOff); cOff+=4; const stscEntries=[];
        for(let i=0;i<cCount;i++){ stscEntries.push([dv.getUint32(cOff),dv.getUint32(cOff+4),dv.getUint32(cOff+8)]); cOff+=12; }

        const stco=stbl.children.find(b=>b.type==='stco'); const co64=stbl.children.find(b=>b.type==='co64');
        let offs=[];
        if(stco){ let oOff=stco.start+stco.header; oOff+=4; const oCount=dv.getUint32(oOff); oOff+=4; for(let i=0;i<oCount;i++) offs.push(dv.getUint32(oOff+i*4)); }
        else if(co64){ let oOff=co64.start+co64.header; oOff+=4; const oCount=dv.getUint32(oOff); oOff+=4; for(let i=0;i<oCount;i++){ const hi=dv.getUint32(oOff+i*8),lo=dv.getUint32(oOff+i*8+4); offs.push(Number((BigInt(hi)<<32n)+BigInt(lo))); } }
        else continue;

        const chunkSampleCounts = Array(offs.length).fill(0);
        for (let i=0;i<stscEntries.length;i++){
          const first=stscEntries[i][0]-1;
          const nextFirst=(i+1<stscEntries.length?stscEntries[i+1][0]-2:offs.length-1);
          const spc=stscEntries[i][1];
          for(let ch=first; ch<=nextFirst; ch++){ if(ch>=0 && ch<chunkSampleCounts.length) chunkSampleCounts[ch]=spc; }
        }
        const sampleOffsets=[]; let sizeIdx=0;
        for(let ch=0; ch<offs.length; ch++){
          const base=offs[ch], spc=chunkSampleCounts[ch]||0;
          let cur=base;
          for(let k=0;k<spc;k++){
            if(sizeIdx>=sizes.length) break;
            const sz=sizes[sizeIdx++]; sampleOffsets.push([cur,sz]); cur+=sz;
          }
          if(sizeIdx>=sizes.length) break;
        }

        const nSamples=Math.min(dts.length,sampleOffsets.length), entries=[];
        for(let i=0;i<nSamples;i++){
          const [soff,sz]=sampleOffsets[i];
          const bytes=new Uint8Array(dv.buffer, soff, sz);
          let title="";
          if(sz>=2){
            const L=(bytes[0]<<8)|bytes[1];
            if(L>0 && 2+L<=bytes.length){ title=new TextDecoder().decode(bytes.slice(2,2+L)); }
          }
          if(!title){
            try{ title=new TextDecoder().decode(bytes); }catch{ try{ title=new TextDecoder('utf-16be').decode(bytes); }catch{ title=""; } }
          }
          entries.push({index:i+1,startSeconds:timescale? dts[i]/timescale:0,title:(title||'').trim()});
        }
        if(entries.length) return {entries,debug:`text-track samples=${entries.length}`};
      }
      return {entries:[],debug:'no text-track'};
    }

    function parseChpl(dv, chplBox, fileDurationSec){
      const start = chplBox.start + chplBox.header, end = chplBox.end;
      if (end - start < 6) return { entries:[], debug:"too small" };
      let off = start;
      const units=[["us",1/1e6],["ms",1/1e3],["sec",1],["cs",1/100],["90k",1/90000]];
      const margin=600;

      function parseLen(base){
        const out=[]; let p=base;
        while(p+9<=end){
          const hi=dv.getUint32(p), lo=dv.getUint32(p+4); p+=8;
          const L=dv.getUint8(p); p+=1;
          if(p+L>end) break;
          const bytes=new Uint8Array(dv.buffer, dv.byteOffset+p, L); p+=L;
          const title=new TextDecoder().decode(bytes);
          const raw=Number((BigInt(hi)<<32n)+BigInt(lo));
          out.push({raw,title});
          if(L===0 && out.length>4096) break;
        }
        return out;
      }
      function parseCStr(base){
        const out=[]; let p=base;
        while(p+9<=end){
          const hi=dv.getUint32(p), lo=dv.getUint32(p+4); p+=8;
          let q=p, found=-1, scanned=0;
          while(q<end && scanned<2048){ if(dv.getUint8(q)===0){found=q;break;} q++; scanned++; }
          if(found<0) break;
          const bytes=new Uint8Array(dv.buffer, dv.byteOffset+p, found-p); p=found+1;
          const raw=Number((BigInt(hi)<<32n)+BigInt(lo));
          const title=new TextDecoder().decode(bytes);
          out.push({raw,title});
          if(out.length>4096) break;
        }
        return out;
      }

      const atts=[];
      for(const layout of ["len","cstr"]){
        for(const skip of [false,true]){
          for(let shift=0; shift<=64; shift++){
            const base=off+(skip?1:0)+shift; if(base>=end) break;
            const raw = (layout==="len") ? parseLen(base) : parseCStr(base);
            if(!raw.length) continue;
            atts.push({layout,skip,shift,raw});
          }
        }
      }
      if(!atts.length) return {entries:[],debug:'no candidates'};

      let bestUnit="us", bestScale=1/1e6, bestCount=-1;
      for(const [uname,scale] of units){
        let c=0;
        for(const a of atts){
          for(const r of a.raw){
            const t=r.raw*scale;
            if(t>=0 && (!fileDurationSec || t<=fileDurationSec+margin)) c++;
          }
        }
        if(c>bestCount){ bestCount=c; bestUnit=uname; bestScale=scale; }
      }

      atts.forEach(a=>{
        a.seq=a.raw.map(r=>({t:r.raw*bestScale,title:r.title}));
        a.inRange=a.seq.filter(e=>e.t>=0 && (!fileDurationSec || e.t<=fileDurationSec+margin));
        a.score=a.inRange.length;
      });
      atts.sort((a,b)=>b.score-a.score);
      const primary=atts[0];
      const merged=[...primary.inRange];
      for(let i=1;i<atts.length;i++){
        for(const e of atts[i].inRange){
          if(!merged.some(m=>Math.abs(m.t-e.t)<=0.2)) merged.push(e);
        }
      }
      merged.sort((a,b)=>a.t-b.t);

      return { entries: merged.map((e,i)=>({index:i+1,startSeconds:e.t,title:e.title})),
               debug:`chpl: unit=${bestUnit}, primary=${primary.layout}/${primary.skip}/${primary.shift}, inRange=${primary.inRange.length}, merged=${merged.length}` };
    }

    function withStops(list, durationSec){
      const out=list.map(c=>({...c}));
      for(let i=0;i<out.length;i++){
        const thisStart=out[i].startSeconds ?? out[i].start ?? 0;
        const nextStart=(i+1<out.length) ? (out[i+1].startSeconds ?? out[i+1].start ?? thisStart) :
                        (Number.isFinite(durationSec)? durationSec : thisStart);
        out[i].start = thisStart;
        out[i].end = Math.max(thisStart, nextStart);
        out[i].title = out[i].title || `Chapter ${String(i+1).padStart(2,'0')}`;
      }
      return out.map(({index,...c},i)=>({title:c.title,start:c.start,end:c.end,index:i+1}));
    }

    async function parseM4BChapters(file){
      try{
        addLog('info','Scanning MP4 boxes…');
        const buf=await file.arrayBuffer();
        const dv=new DataView(buf);
        const root=parseTree(dv,0,buf.byteLength);
        const dur=getDurationSeconds(dv,root);
        if(dur) addLog('info',`Duration (mvhd): ${fmt(dur)} (${dur.toFixed(3)} s)`);

        const textRes=parseTextTrack(dv,root);
        if(textRes.entries.length){
          addLog('info',`Found QuickTime text-track chapters. ${textRes.debug}`);
          AUDIO_CH = withStops(textRes.entries.sort((a,b)=>a.startSeconds-b.startSeconds), dur);
          populateAudioChapterUI();
          return;
        }

        const udta=findPath(root,["moov","udta"]);
        const chpl=udta?.children?.find(b=>b.type==='chpl');
        if(chpl){
          const chplRes=parseChpl(dv,chpl,dur||null);
          addLog('info',`Found Nero chpl. ${chplRes.debug}`);
          AUDIO_CH = withStops(chplRes.entries.sort((a,b)=>a.startSeconds-b.startSeconds), dur);
          populateAudioChapterUI();
          return;
        }

        addLog('warn','No chapters found; using single chapter');
        AUDIO_CH = [{title:file.name,start:0,end:dur||999999,index:1}];
        populateAudioChapterUI();
      }catch(e){
        addLog('warn','m4b parse failed — single chapter', String(e));
        AUDIO_CH=[{title:file.name,start:0,end:999999,index:1}];
        populateAudioChapterUI();
      }
    }

    /* ===== EPUB TOC/chapters ===== */
    async function parseEpubChapters(file){
      addLog('info','Parsing EPUB container…');
      const zip = await JSZip.loadAsync(file);
      const containerXml = await zip.file('META-INF/container.xml')?.async('text');
      if(!containerXml){ addLog('error','container.xml missing in EPUB'); TEXT_CH=[]; populateTextChapterUI(); return; }
      const dp=new DOMParser();
      const containerDoc = dp.parseFromString(containerXml,'application/xml');
      const rootfile = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
      if(!rootfile){ addLog('error','OPF path missing'); TEXT_CH=[]; populateTextChapterUI(); return; }
      const opfText = await zip.file(rootfile)?.async('text');
      if(!opfText){ addLog('error','OPF not found'); TEXT_CH=[]; populateTextChapterUI(); return; }
      const opfDoc = dp.parseFromString(opfText,'application/xml');
      const opfDir = rootfile.split('/').slice(0,-1).join('/');
      const resolveHref = (href)=> (opfDir?opfDir+'/':'') + href;

      const manifest = {};
      opfDoc.querySelectorAll('manifest > item').forEach(it=>{
        manifest[it.getAttribute('id')] = {
          href: it.getAttribute('href'),
          type: it.getAttribute('media-type')
        };
      });
      const spineIds = Array.from(opfDoc.querySelectorAll('spine > itemref')).map(n=>n.getAttribute('idref')).filter(Boolean);

      async function extractFromNav(item){
        const href = resolveHref(item.href);
        const navHtml = await zip.file(href)?.async('text');
        if(!navHtml) return [];
        const doc = dp.parseFromString(navHtml,'text/html');
        const tocNav = doc.querySelector('nav[epub\\:type="toc"], nav[type="toc"], nav[role="doc-toc"]') || doc.querySelector('nav');
        if(!tocNav) return [];
        const items=[];
        tocNav.querySelectorAll('li > a').forEach((a,i)=>{
          const title=(a.textContent||`Chapter ${i+1}`).trim();
          const link=a.getAttribute('href')||'';
          items.push({title, href: link});
        });
        return items;
      }
      async function extractFromNCX(ncxItem){
        const href = resolveHref(ncxItem.href);
        const ncxXml = await zip.file(href)?.async('text'); if(!ncxXml) return [];
        const doc = dp.parseFromString(ncxXml,'application/xml');
        const items=[];
        doc.querySelectorAll('navMap navPoint').forEach((np,i)=>{
          const title = (np.querySelector('navLabel text')?.textContent || `Chapter ${i+1}`).trim();
          const src = np.querySelector('content')?.getAttribute('src') || '';
          items.push({title, href: src});
        });
        return items;
      }

      let tocEntries=[];
      const navEntry = Object.values(manifest).find(m=>/xhtml|html/i.test(m.type)&&/nav/i.test(m.type) || /nav\.x?html$/i.test(m.href));
      if(navEntry){ tocEntries = await extractFromNav(navEntry); }
      if(!tocEntries.length){
        const ncxEntry = Object.values(manifest).find(m=>/application\/x-dtbncx\+xml/i.test(m.type) || /\.ncx$/i.test(m.href));
        if(ncxEntry) tocEntries = await extractFromNCX(ncxEntry);
      }
      if(!tocEntries.length){
        tocEntries = spineIds.map((id,idx)=>({title:`Chapter ${idx+1}`, href: manifest[id]?.href || ''}));
      }

      async function readContent(hrefRaw){
        if(!hrefRaw) return '';
        const href = resolveHref(hrefRaw.split('#')[0]);
        const html = await zip.file(href)?.async('text'); if(!html) return '';
        const doc = dp.parseFromString(html,'text/html');
        doc.querySelectorAll('script,style,noscript').forEach(n=>n.remove());
        return (doc.body?.textContent||'').replace(/\s+/g,' ').trim();
      }

      const out=[];
      for(let i=0;i<tocEntries.length;i++){
        const it=tocEntries[i];
        const text=await readContent(it.href);
        if(text && text.length>0) out.push({title:it.title, text, idx:i});
      }
      TEXT_CH=out;
      populateTextChapterUI();
      addLog('info','EPUB chapters parsed',{count:TEXT_CH.length});
    }

    /* ===== Chapter → WAV helpers (16 kHz mono, WAV container) ===== */
    function safeFileStem(s){ return String(s||'audio').replace(/[^\w\-]+/g,'_').slice(0,80) }
    function fmtBytes(n){ if(!Number.isFinite(n)) return '—'; const u=['B','KB','MB','GB']; let i=0; while(n>=1024&&i<u.length-1){n/=1024;i++} return n.toFixed(1)+' '+u[i] }

    async function sliceCurrentToWavBlob(){
      const isM4B = AUDIO_FILE && /\.m4b$/i.test(AUDIO_FILE.name||'');
      const idx = getSelectedAudioIndex();
      const fallbackDur = DECODE_CACHE?.durationSec || 0;
      const ch  = AUDIO_CH[idx] || { title:'chapter', start:0, end:fallbackDur };

      if (isM4B){
        const blob = await m4bSliceToWavUsingFFmpeg(AUDIO_FILE, ch.start, ch.end);
        const name = `${safeFileStem(ch.title || AUDIO_FILE.name)}.wav`;
        const sr = 16000;
        return { blob, name, sr, samples: Math.max(1, Math.round((ch.end-ch.start)*sr)), dur: Math.max(0, ch.end-ch.start) };
      }

      const cache = await ensureDecode();
      const sr  = cache.sr;
      const s0  = Math.floor(ch.start * sr);
      const s1  = Math.floor(Math.min(ch.end, cache.durationSec) * sr);
      const f32 = cache.f32.subarray(s0, s1);
      const i16 = floatToInt16(f32);
      const wav = writeWavPCM16(i16, sr);
      const stem = safeFileStem(ch.title || (AUDIO_FILE?.name || 'audio'));
      const name = `${stem}.wav`;
      return { blob: wav, name, sr, samples: i16.length, dur: (i16.length/sr) };
    }

    async function sliceReplaceWithWav(){
      try{
        setStatus('Slicing current chapter to WAV…');
        const { blob, name, sr, samples, dur } = await sliceCurrentToWavBlob();
        const wavFile = new File([blob], name, { type: 'audio/wav' });
        AUDIO_FILE = wavFile;
        DECODE_CACHE = null;
        CHAPTER_MODE = false;
        AUDIO_CH = [{ title: name, start: 0, end: dur, index: 1 }];
        CURRENT_AUDIO_CH_INDEX = 0;
        populateAudioChapterUI();

        const url = URL.createObjectURL(wavFile);
        el.player && (el.player.src = url, el.player.load());
        el.playerDesktop && (el.playerDesktop.src = url, el.playerDesktop.load());

        if (IS_MOBILE) { el.mTitle.textContent = name; } else { el.audioTitle && (el.audioTitle.textContent = name); }

        const meta = `WAV • mono ${sr} Hz • ${fmtBytes(blob.size)} • ${fmt(dur).slice(0,5)}`;
        const infoEl = document.getElementById('sliceMeta');
        if (infoEl) infoEl.textContent = meta;

        addLog('info','Slice → Use WAV complete', { name, sr, samples, bytes: blob.size, seconds: dur.toFixed(3) });
        setStatus(`<span class="accent">Ready</span> ${name} — use “Transcribe” as usual`);
      }catch(e){
        addLog('error','Slice → Use WAV failed', String(e));
        alert('Slice failed — see Log for details.');
      }
    }

    function writeWavPCM16(samplesI16, sampleRate){
      const numChannels=1, bitsPerSample=16;
      const blockAlign=numChannels*bitsPerSample/8;
      const byteRate=sampleRate*blockAlign;
      const dataSize=samplesI16.length*2;
      const buf=new ArrayBuffer(44+dataSize);
      const dv=new DataView(buf);
      let p=0;
      function w4(s){for(let i=0;i<4;i++) dv.setUint8(p++,s.charCodeAt(i));}
      function w2(v){dv.setUint16(p,v,true); p+=2;}
      function w4u(v){dv.setUint32(p,v,true); p+=4;}
      w4('RIFF'); w4u(36+dataSize); w4('WAVE');
      w4('fmt '); w4u(16); w2(1); w2(numChannels); w4u(sampleRate); w4u(byteRate); w2(blockAlign); w2(bitsPerSample);
      w4('data'); w4u(dataSize);
      const out=new Int16Array(buf,44,samplesI16.length);
      out.set(samplesI16);
      return new Blob([buf],{type:'audio/wav'});
    }

    async function exportCurrentChapterWav(){
      try{
        const isM4B = AUDIO_FILE && /\.m4b$/i.test(AUDIO_FILE.name||'');
        const idx = getSelectedAudioIndex();
        const ch  = AUDIO_CH[idx] || {start:0,end:(DECODE_CACHE?.durationSec||0),title:'chapter'};

        let blob, sr, bytes;
        if (isM4B){
          setStatus('Exporting WAV via ffmpeg…');
          blob = await m4bSliceToWavUsingFFmpeg(AUDIO_FILE, ch.start, ch.end);
          sr = 16000;
          bytes = blob.size;
        } else {
          const cache=await ensureDecode();
          const s0=Math.floor(ch.start*cache.sr);
          const s1=Math.floor(Math.min(ch.end,cache.durationSec)*cache.sr);
          const i16=floatToInt16(cache.f32.subarray(s0,s1));
          blob=writeWavPCM16(i16,cache.sr);
          sr = cache.sr;
          bytes = 44 + i16.length*2;
        }

        const a=document.createElement('a');
        const safeTitle=(ch.title||'chapter').replace(/[^\w\-]+/g,'_').slice(0,80);
        a.href=URL.createObjectURL(blob);
        a.download=`${safeTitle}.wav`;
        a.click();

        addLog('info','Exported WAV',{ sampleRate:sr, bytes, chapter: { start: ch.start, end: ch.end } });
        setStatus(`<span class="accent">Exported</span> ${safeTitle}.wav`);
      }catch(e){
        addLog('error','Export WAV failed', String(e));
        alert('Export failed (see log).');
      }
    }
    el.exportWav?.addEventListener('click', exportCurrentChapterWav);
    el.sliceReplaceWav?.addEventListener('click', sliceReplaceWithWav);

    /* ===== Init & controls ===== */
    addLog('info','Ready. Auto-detecting model in background (no model UI).');
    addLog('info','Env',{ua:navigator.userAgent,deviceMemory:navigator.deviceMemory||null});

    // main actions
    el.go && (el.go.onclick=()=>run().catch(e=>addLog('error','Top level failure',String(e))));
    el.align && (el.align.onclick=()=>{try{
      if(!LAST_WORDS.length){alert('Transcribe first');return}
      const refTxt= (CHAPTER_MODE && TEXT_CH[(CURRENT_AUDIO_CH_INDEX+MAP_OFFSET)]?.text) || REF_TEXT || '';
      if(!refTxt){alert('Load an EPUB or TXT to align against.');return}
      const corrected=alignAndCorrect(LAST_WORDS,refTxt);
      addLog('info','Alignment complete',{orig:LAST_WORDS.length,corrected:corrected.length});
      LAST_WORDS=corrected;PLAY_WORDS=normalizeForPlayback(LAST_WORDS);buildHighlightWindows();render(PLAY_WORDS);updateHighlightFromPlayer();ALIGNED_ONCE=true;refreshAlignButton()
    }catch(e){addLog('error','Align failed',String(e));alert('Align failed — see log')}});

    refreshAlignButton();

    // mobile transport
    if(IS_MOBILE){
      const p=activePlayer();
      el.mPrev&&(el.mPrev.onclick=()=>{p.currentTime=Math.max(0,p.currentTime-10)});
      el.mNext&&(el.mNext.onclick=()=>{if(isFinite(p.duration)) p.currentTime=Math.min(p.duration,p.currentTime+10)});
      function syncPlayBtn(){ el.mPlay.textContent=p.paused?'▶':'⏸'; }
      el.mPlay&&(el.mPlay.onclick=()=>{p.paused?p.play():p.pause(); syncPlayBtn()});
      p.addEventListener('play',syncPlayBtn); p.addEventListener('pause',syncPlayBtn);
    }

    // keep times updating
    setInterval(()=>{ if(IS_MOBILE) setMobileTimes(); }, 250);

    // Optional: open the drawer by default on desktop so controls are obvious
    if (!IS_MOBILE) setTimeout(() => setDrawer(true), 0);
    
    probeFfmpegAvailabilityOnce();
  </script>
</body>
</html>
