<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FFmpeg WASM — M4B Chapter to WAV (Local-First, Static UMD)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Prefer the local UMD so document.currentScript works (needs the split chunk beside it). -->
  <script src="./ffmpeg/ffmpeg.min.js"></script>
  <!-- Make sure the split chunk shipped with your ffmpeg.min.js is present too (e.g. 814.ffmpeg.min.js). -->

  <style>
    :root{--bg:#0f1216;--panel:#161b21;--fg:#e8eef7;--muted:#9aa6b2;--line:#273044;--accent:#ffd666}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,Segoe UI,Arial,sans-serif}
    .wrap{max-width:880px;margin:24px auto;padding:16px}
    h1{font-size:18px;margin:0 0 12px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:16px;margin-bottom:16px}
    label{display:block;margin:8px 0 6px;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.06em}
    input[type="file"]{display:block}
    select{width:100%;min-height:220px;background:#0d1219;color:var(--fg);border:1px solid var(--line);border-radius:8px;padding:8px}
    button{background:var(--accent);color:#111;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.5;cursor:not-allowed}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .log{white-space:pre-wrap;background:#0d1219;border:1px solid var(--line);border-radius:8px;padding:10px;min-height:140px;max-height:260px;overflow:auto}
    .hint{color:var(--muted);font-size:12px;margin-top:6px}
    .inline{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  </style>

  <script>
    // Wait helper
    function waitFor(pred, ms = 20000, step = 50) {
      return new Promise((resolve, reject) => {
        const t0 = performance.now();
        (function poll(){
          if (pred()) return resolve();
          if (performance.now() - t0 > ms) return reject(new Error('timeout'));
          setTimeout(poll, step);
        })();
      });
    }

    // Core sources for each runtime flavor
    const CORE_URLS = {
      umd: {
        js  : 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js',
        wasm: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.wasm'
      },
      esm: {
        js  : 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/esm/ffmpeg-core.js',
        wasm: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/esm/ffmpeg-core.wasm'
      }
    };

    async function toBlobURL(url, mime) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`fetch failed ${r.status} ${url}`);
      const b = await r.arrayBuffer();
      return URL.createObjectURL(new Blob([b], { type: mime }));
    }

    // Local ESM entry (present in your repo). If you prefer CDN, you can point this to jsDelivr.
    const ESM_INDEX = new URL('./ffmpeg/esm/index.js', location.href).toString(); // exports { FFmpeg }

    let gFFmpeg = null;

    async function ensureFFmpeg() {
      if (gFFmpeg) return gFFmpeg;

      let FFmpegCtor = null;
      let flavor = 'umd';

      // 1) Try the statically-loaded UMD first
      try {
        await waitFor(() => !!(window.FFmpeg && window.FFmpeg.FFmpeg), 20000, 50);
        FFmpegCtor = window.FFmpeg.FFmpeg;
        console.log('[FFMPEG] UMD detected.');
      } catch (e) {
        console.warn('[FFMPEG] UMD not detected in time, using ESM fallback:', e?.message || e);
      }

      // 2) Fallback to ESM
      if (!FFmpegCtor) {
        const mod = await import(ESM_INDEX);
        FFmpegCtor = mod.FFmpeg;
        flavor = 'esm';
        console.log('[FFMPEG] ESM loaded.');
      }

      // 3) Load matching core for the selected flavor
      const ffmpeg = new FFmpegCtor();
      const coreSet = CORE_URLS[flavor];
      const coreURL = await toBlobURL(coreSet.js, 'text/javascript');
      const wasmURL = await toBlobURL(coreSet.wasm, 'application/wasm');
      await ffmpeg.load({ coreURL, wasmURL });

      gFFmpeg = ffmpeg;
      return ffmpeg;
    }
  </script>
</head>
<body>
  <div class="wrap">
    <h1>FFmpeg WASM — M4B Chapter to WAV (Local-First Test)</h1>

    <div class="card">
      <label>1) Choose an .m4b file</label>
      <input id="file" type="file" accept=".m4b,audio/m4b,audio/mp4,audio/x-m4b,audio/aac,audio/mp4a-latm" />
      <div class="hint">Stays in your browser; no uploads.</div>
    </div>

    <div class="card">
      <div class="row">
        <div>
          <label>2) Chapters (from ffmetadata)</label>
          <select id="chapters" size="12"></select>
          <div class="hint">If nothing appears, the file may not expose chapters via ffmetadata.</div>
        </div>
        <div>
          <label>Export settings</label>
          <div class="inline">
            <span>Sample rate</span>
            <select id="sr">
              <option value="16000" selected>16000 Hz (mono)</option>
              <option value="22050">22050 Hz (mono)</option>
              <option value="44100">44100 Hz (mono)</option>
            </select>
          </div>
          <div class="inline" style="margin-top:10px">
            <button id="exportBtn" disabled>3) Export selected chapter as WAV</button>
            <a id="dl" style="display:none" download="chapter.wav">Download WAV</a>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <label>Log</label>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    const el = (id) => document.getElementById(id);
    const logBox = el('log');
    function log(...args){ logBox.textContent += args.join(' ') + '\n'; logBox.scrollTop = logBox.scrollHeight; }

    // HH:MM:SS.mmm helper
    function toHMS(sec) {
      const s = Math.max(0, +sec);
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), r = (s%60);
      const mm = String(m).padStart(2,'0'), ss = String(Math.floor(r)).padStart(2,'0');
      const ms = String(Math.round((r - Math.floor(r))*1000)).padStart(3,'0');
      return (h>0? (String(h).padStart(2,'0')+':') : '') + mm + ':' + ss + (ms!=='000'? '.'+ms : '');
    }

    function parseFfmetadata(text) {
      const lines = text.split(/\r?\n/);
      const out = [];
      let cur = null, tbNum = 1, tbDen = 1000;
      const toSec = (ticks) => (ticks * (tbNum / tbDen));
      for (let raw of lines) {
        const line = raw.trim();
        if (!line || line.startsWith(';')) continue;
        if (line === '[CHAPTER]') { if (cur) out.push(cur); cur = { title:'', startSec:0, endSec:null }; tbNum=1; tbDen=1000; }
        else if (line.startsWith('TIMEBASE=')) { const v=line.slice(9).split('/'); tbNum=+v[0]||1; tbDen=+v[1]||1000; }
        else if (line.startsWith('START=')) { if (cur) cur.startSec = toSec(parseInt(line.slice(6),10)||0); }
        else if (line.startsWith('END=')) { if (cur) cur.endSec = toSec(parseInt(line.slice(4),10)||0); }
        else if (line.startsWith('title=')) { if (cur) cur.title = line.slice(6); }
      }
      if (cur) out.push(cur);
      out.forEach((c,i)=>{ if (c.endSec!=null && c.endSec<c.startSec) c.endSec=c.startSec; if(!c.title) c.title=`Chapter ${String(i+1).padStart(2,'0')}`;});
      return out;
    }

    function secondsToFfmpegTime(sec) {
      const s = Math.max(0, +sec);
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), r = s - (h*3600 + m*60);
      const hh=String(h).padStart(2,'0'), mm=String(m).padStart(2,'0'), ss=String(Math.floor(r)).padStart(2,'0');
      const ms=String(Math.round((r - Math.floor(r))*1000)).padStart(3,'0');
      return `${hh}:${mm}:${ss}.${ms}`;
    }

    let currentFileBytes = null, currentFileName = '', chapters = [];

    async function extractMetadata(ffmpeg, nameInFS) {
      log('[INFO] Extracting chapters via ffmetadata…');
      try {
        try { ffmpeg.FS('unlink','meta.txt'); } catch {}
        await ffmpeg.exec(['-hide_banner','-i', nameInFS, '-f', 'ffmetadata', 'meta.txt']);
        const meta = ffmpeg.FS('readFile', 'meta.txt');
        return new TextDecoder().decode(meta);
      } catch (e) {
        log('[ERROR] Could not extract ffmetadata:', e.message||e);
        return '';
      }
    }

    function populateChapterList(list) {
      const sel = el('chapters'); sel.innerHTML = '';
      list.forEach((c, idx) => {
        const opt = document.createElement('option');
        const start = toHMS(c.startSec);
        const end = (c.endSec!=null ? toHMS(c.endSec) : 'end');
        opt.value = String(idx);
        opt.textContent = `${String(idx+1).padStart(2,'0')} — ${c.title}  (${start} → ${end})`;
        sel.appendChild(opt);
      });
      el('exportBtn').disabled = !list.length;
    }

    async function exportChapter() {
      const sel = el('chapters'); const idx = parseInt(sel.value,10);
      if (Number.isNaN(idx)) return;
      const sr = String(el('sr').value || '16000');
      const chap = chapters[idx];
      const start = secondsToFfmpegTime(chap.startSec);
      const durationSec = (chap.endSec!=null && chap.endSec>chap.startSec) ? (chap.endSec - chap.startSec) : null;

      log(`[INFO] Exporting chapter #${idx+1} — "${chap.title}"`);
      const ffmpeg = await ensureFFmpeg();

      const inName = 'in.m4b', outName = 'chapter.wav';
      try { ffmpeg.FS('unlink', inName); } catch {}
      ffmpeg.FS('writeFile', inName, currentFileBytes);
      try { ffmpeg.FS('unlink', outName); } catch {}

      ffmpeg.on('log', ({ message }) => { if (message) log(message); });
      ffmpeg.on('progress', ({ progress, time }) => {
        const pct = Math.round((progress||0)*100);
        if (!Number.isNaN(pct)) log(`[PROGRESS] ${pct}%  time=${(time||0)/1e6}s`);
      });

      const args = ['-hide_banner','-ss', start, '-i', inName];
      if (durationSec!=null) args.push('-t', String(durationSec));
      args.push('-vn','-ac','1','-ar', sr,'-c:a','pcm_s16le', outName);

      log('[CMD]', 'ffmpeg ' + args.join(' '));
      try {
        await ffmpeg.exec(args);
        const wav = ffmpeg.FS('readFile', outName);
        const a = el('dl');
        a.href = URL.createObjectURL(new Blob([wav.buffer], { type:'audio/wav' }));
        a.download = (currentFileName.replace(/\.[^.]+$/,'') || 'chapter') + ` — ${String(idx+1).padStart(2,'0')}.wav`;
        a.style.display = 'inline-block'; a.textContent = 'Download WAV';
        log('[OK] Export complete. Click "Download WAV".');
      } catch (e) {
        log('[ERROR] Export failed:', e.message||e);
      }
    }

    el('file').addEventListener('change', async (ev) => {
      const f = ev.target.files?.[0]; if (!f) return;
      el('chapters').innerHTML=''; el('exportBtn').disabled=true; el('dl').style.display='none'; logBox.textContent='';

      currentFileName = f.name;
      log(`[INFO] File selected — ${f.name} (${f.size.toLocaleString()} bytes)`);

      try {
        const ffmpeg = await ensureFFmpeg();
        log('[OK] FFmpeg ready.');

        const buf = await f.arrayBuffer();
        currentFileBytes = new Uint8Array(buf);
        try { ffmpeg.FS('unlink','in.m4b'); } catch {}
        ffmpeg.FS('writeFile','in.m4b', currentFileBytes);
        log('[INFO] File written to FFmpeg FS as "in.m4b".');

        const metaText = await extractMetadata(ffmpeg, 'in.m4b');
        if (!metaText) { log('[WARN] ffmetadata empty.'); return; }
        chapters = parseFfmetadata(metaText);
        if (!chapters.length) { log('[WARN] No [CHAPTER] entries in ffmetadata.'); return; }
        log(`[OK] Found ${chapters.length} chapters.`);
        populateChapterList(chapters);
      } catch (e) {
        log('[ERROR] Setup failed:', e.message||e);
      }
    });

    el('exportBtn').addEventListener('click', exportChapter);
  </script>
</body>
</html>
