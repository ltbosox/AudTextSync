<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FFmpeg WASM — M4B Chapter to WAV (Test)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f1216;--panel:#161b21;--fg:#e8eef7;--muted:#9aa6b2;--line:#273044;--accent:#ffd666;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,Segoe UI,Arial,sans-serif}
    .wrap{max-width:880px;margin:24px auto;padding:16px}
    h1{font-size:18px;margin:0 0 12px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:16px;margin-bottom:16px}
    label{display:block;margin:8px 0 6px;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.06em}
    input[type="file"]{display:block}
    select{width:100%;min-height:220px;background:#0d1219;color:var(--fg);border:1px solid var(--line);border-radius:8px;padding:8px}
    button{background:var(--accent);color:#111;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.5;cursor:not-allowed}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .log{white-space:pre-wrap;background:#0d1219;border:1px solid var(--line);border-radius:8px;padding:10px;min-height:140px;max-height:260px;overflow:auto}
    .hint{color:var(--muted);font-size:12px;margin-top:6px}
    .inline{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .ok{color:#6ee7a8}
    .bad{color:#fca5a5}
  </style>

  <!-- Robust FFmpeg UMD loader (works on GitHub Pages) -->
  <script>
    async function loadScript(src, timeoutMs = 12000) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        const timer = setTimeout(() => { s.remove(); reject(new Error('timeout')); }, timeoutMs);
        s.onload = () => { clearTimeout(timer); resolve(); };
        s.onerror = (e) => { clearTimeout(timer); reject(e?.error || new Error('network error')); };
        s.src = src; s.async = true; document.head.appendChild(s);
      });
    }
    const FFMPEG_UMD = [
      'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.10/umd/ffmpeg.min.js', // ✅ has .min.js
      'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js', // non-min fallback
      'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js',            // non-min fallback
      `${location.origin}/AudTextSync/ffmpeg/ffmpeg.min.js`,                     // your Pages copy (if added)
    ];
    let gFFmpeg = null;

    async function ensureFFmpeg() {
      if (gFFmpeg) return gFFmpeg;
      // Load the UMD entry
      for (const url of FFMPEG_UMD) {
        try { await loadScript(url, 12000); if (window.FFmpeg) break; } catch (_) {}
      }
      if (!window.FFmpeg) throw new Error('Failed to load @ffmpeg/ffmpeg UMD');

      const { FFmpeg } = window.FFmpeg;
      const ffmpeg = new FFmpeg();
      // Load the matching UMD core from cdnjs (worker+wasm friendly on Pages)
      await ffmpeg.load({
        coreURL:   'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg-core/0.12.10/umd/ffmpeg-core.js',
        wasmURL:   'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg-core/0.12.10/umd/ffmpeg-core.wasm',
        workerURL: 'https://cdnjs.cloudflare.com/ajax/libs/ffmpeg-core/0.12.10/umd/ffmpeg-core.worker.js',
      });
      gFFmpeg = ffmpeg;
      return ffmpeg;
    }
  </script>
</head>
<body>
  <div class="wrap">
    <h1>FFmpeg WASM — M4B Chapter to WAV (Test Harness)</h1>

    <div class="card">
      <label>1) Choose an .m4b file</label>
      <input id="file" type="file" accept=".m4b,audio/m4b,audio/mp4,audio/x-m4b,audio/aac,audio/mp4a-latm" />
      <div class="hint">Large files will be read into memory for testing. This page doesn’t upload anything.</div>
    </div>

    <div class="card">
      <div class="row">
        <div>
          <label>2) Chapters (from ffmetadata)</label>
          <select id="chapters" size="12"></select>
          <div class="hint">If nothing shows up, the file may not contain chapters readable via ffmetadata.</div>
        </div>
        <div>
          <label>Export settings</label>
          <div class="inline">
            <span>Sample rate</span>
            <select id="sr">
              <option value="16000" selected>16000 Hz (mono)</option>
              <option value="22050">22050 Hz (mono)</option>
              <option value="44100">44100 Hz (mono)</option>
            </select>
          </div>
          <div class="inline" style="margin-top:10px">
            <button id="exportBtn" disabled>3) Export selected chapter as WAV</button>
            <a id="dl" style="display:none" download="chapter.wav">Download WAV</a>
          </div>
          <div class="hint">After export completes, a download link will appear.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <label>Log</label>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    const el = (id) => document.getElementById(id);
    const logBox = el('log');
    function log(...args){ logBox.textContent += args.join(' ') + '\n'; logBox.scrollTop = logBox.scrollHeight; }

    // Utility: HH:MM:SS.mmm <-> seconds
    function toHMS(sec) {
      const s = Math.max(0, +sec);
      const h = Math.floor(s/3600);
      const m = Math.floor((s%3600)/60);
      const r = (s%60);
      const mm = String(m).padStart(2,'0');
      const ss = String(Math.floor(r)).padStart(2,'0');
      const ms = String(Math.round((r - Math.floor(r))*1000)).padStart(3,'0');
      return (h>0? (String(h).padStart(2,'0')+':') : '') + mm + ':' + ss + (ms!=='000'? '.'+ms : '');
    }

    function parseFfmetadata(text) {
      // Expects FFMETADATA1 format. We only extract [CHAPTER] sections.
      // TIMEBASE=N/D, START, END, title=...
      const lines = text.split(/\r?\n/);
      const chapters = [];
      let cur = null, tbNum = 1, tbDen = 1000;
      const toSec = (ticks) => (ticks * (tbNum / tbDen));

      for (let raw of lines) {
        const line = raw.trim();
        if (!line || line.startsWith(';')) continue;
        if (line === '[CHAPTER]') {
          if (cur) chapters.push(cur);
          cur = { title: '', startSec: 0, endSec: null };
          tbNum = 1; tbDen = 1000; // reset to common default unless overridden
        } else if (line.startsWith('TIMEBASE=')) {
          const v = line.slice(9).split('/');
          tbNum = parseInt(v[0]||'1',10);
          tbDen = parseInt(v[1]||'1000',10) || 1;
        } else if (line.startsWith('START=')) {
          const ticks = parseInt(line.slice(6),10)||0;
          if (cur) cur.startSec = toSec(ticks);
        } else if (line.startsWith('END=')) {
          const ticks = parseInt(line.slice(4),10)||0;
          if (cur) cur.endSec = toSec(ticks);
        } else if (line.startsWith('title=')) {
          if (cur) cur.title = line.slice(6);
        }
      }
      if (cur) chapters.push(cur);

      // Clean up: ensure non-decreasing, round ms to 3 decimals
      chapters.forEach((c,i) => {
        if (c.endSec!=null && c.endSec < c.startSec) c.endSec = c.startSec;
        c.startSec = Math.max(0, +c.startSec);
        if (c.endSec!=null) c.endSec = Math.max(c.startSec, +c.endSec);
        if (!c.title) c.title = `Chapter ${String(i+1).padStart(2,'0')}`;
      });
      return chapters;
    }

    let currentFileBytes = null;
    let currentFileName = '';
    let chapters = [];

    async function extractMetadata(ffmpeg, nameInFS) {
      // Create ffmetadata file from input
      log('[INFO] Extracting chapters via ffmetadata…');
      try {
        // cleanup old meta if any
        try { ffmpeg.FS('unlink', 'meta.txt'); } catch {}
        await ffmpeg.exec(['-hide_banner','-i', nameInFS, '-f', 'ffmetadata', 'meta.txt']);
        const meta = ffmpeg.FS('readFile', 'meta.txt');
        const text = new TextDecoder().decode(meta);
        return text;
      } catch (e) {
        log('[ERROR] Could not extract ffmetadata:', e.message || e);
        return '';
      }
    }

    function populateChapterList(chapters) {
      const sel = el('chapters');
      sel.innerHTML = '';
      chapters.forEach((c, idx) => {
        const start = toHMS(c.startSec);
        const end = (c.endSec!=null ? toHMS(c.endSec) : 'end');
        const opt = document.createElement('option');
        opt.value = String(idx);
        opt.textContent = `${String(idx+1).padStart(2,'0')} — ${c.title}  (${start} → ${end})`;
        sel.appendChild(opt);
      });
      el('exportBtn').disabled = chapters.length === 0;
    }

    function secondsToFfmpegTime(sec) {
      // HH:MM:SS.mmm (keep 3 decimals)
      const s = Math.max(0, +sec);
      const h = Math.floor(s/3600);
      const m = Math.floor((s%3600)/60);
      const r = s - (h*3600 + m*60);
      const hh = String(h).padStart(2,'0');
      const mm = String(m).padStart(2,'0');
      const ss = String(Math.floor(r)).padStart(2,'0');
      const ms = String(Math.round((r - Math.floor(r))*1000)).padStart(3,'0');
      return `${hh}:${mm}:${ss}.${ms}`;
    }

    async function exportChapter() {
      const sel = el('chapters');
      const idx = parseInt(sel.value,10);
      if (Number.isNaN(idx)) return;

      const sr = String(el('sr').value || '16000');
      const chap = chapters[idx];
      const start = secondsToFfmpegTime(chap.startSec);
      const hasEnd = (chap.endSec != null && chap.endSec > chap.startSec);
      const durationSec = hasEnd ? (chap.endSec - chap.startSec) : null;

      log(`[INFO] Exporting chapter #${idx+1} — "${chap.title}"`);
      const ffmpeg = await ensureFFmpeg();

      // Write input again (idempotent OK), then run slice
      const inName = 'in.m4b';
      try { ffmpeg.FS('unlink', inName); } catch {}
      ffmpeg.FS('writeFile', inName, currentFileBytes);

      // Clean previous output
      const outName = 'chapter.wav';
      try { ffmpeg.FS('unlink', outName); } catch {}

      // Hook logs/progress
      ffmpeg.on('log', ({ message }) => { if (message) log(message); });
      ffmpeg.on('progress', ({ progress, time }) => {
        const pct = Math.round((progress || 0)*100);
        if (!Number.isNaN(pct)) log(`[PROGRESS] ${pct}%  time=${toHMS((time||0)/1000000)}`);
      });

      // Build args: fast seek with -ss BEFORE -i, then limit with -t if we know duration
      const args = ['-hide_banner', '-ss', start, '-i', inName];
      if (durationSec != null) {
        args.push('-t', String(durationSec));
      }
      args.push(
        '-vn', '-ac', '1', '-ar', sr, '-c:a', 'pcm_s16le', outName
      );

      log('[CMD]', 'ffmpeg ' + args.join(' '));
      try {
        await ffmpeg.exec(args);
        const wav = ffmpeg.FS('readFile', outName);
        const blob = new Blob([wav.buffer], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        const a = el('dl');
        a.href = url;
        a.download = (currentFileName.replace(/\.[^.]+$/,'') || 'chapter') + ` — ${String(idx+1).padStart(2,'0')}.wav`;
        a.style.display = 'inline-block';
        a.textContent = 'Download WAV';
        log('[OK] Export complete. Click "Download WAV".');
      } catch (e) {
        log('[ERROR] Export failed:', e.message || e);
      }
    }

    // Wire up UI
    el('file').addEventListener('change', async (ev) => {
      const f = ev.target.files?.[0];
      if (!f) return;
      el('chapters').innerHTML = '';
      el('exportBtn').disabled = true;
      el('dl').style.display = 'none';
      logBox.textContent = '';

      currentFileName = f.name;
      log(`[INFO] File selected — ${f.name} (${f.size.toLocaleString()} bytes)`);

      try {
        const ffmpeg = await ensureFFmpeg();
        log('[OK] FFmpeg loaded.');

        // Load file into memory and FS
        const buf = await f.arrayBuffer();
        currentFileBytes = new Uint8Array(buf);
        try { ffmpeg.FS('unlink', 'in.m4b'); } catch {}
        ffmpeg.FS('writeFile', 'in.m4b', currentFileBytes);
        log('[INFO] File written to FFmpeg FS as "in.m4b".');

        // Extract chapters via ffmetadata
        const text = await extractMetadata(ffmpeg, 'in.m4b');
        if (!text) {
          log('[WARN] ffmetadata empty. No chapters found or unsupported container.');
          return;
        }
        chapters = parseFfmetadata(text);
        if (!chapters.length) {
          log('[WARN] No [CHAPTER] entries in ffmetadata. The file may not have chapters.');
          return;
        }
        log(`[OK] Found ${chapters.length} chapters.`);
        populateChapterList(chapters);
      } catch (e) {
        log('[ERROR] Setup failed:', e.message || e);
      }
    });

    el('exportBtn').addEventListener('click', exportChapter);
  </script>
</body>
</html>
